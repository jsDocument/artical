(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{234:function(v,_,l){"use strict";l.r(_);var t=l(6),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"浏览器进程分类"}},[v._v("浏览器进程分类")]),v._v(" "),l("ul",[l("li",[v._v("浏览器主进程：协调、主控(浏览器界面显示，用户交互，其他进程的创建与销毁)")]),v._v(" "),l("li",[v._v("第三方插件进程")]),v._v(" "),l("li",[v._v("GPU 进程")]),v._v(" "),l("li",[v._v("浏览器渲染进程：页面渲染、脚本执行、事件处理\n"),l("ul",[l("li",[v._v("GUI 渲染线程")]),v._v(" "),l("li",[v._v("JS 引擎线程")]),v._v(" "),l("li",[v._v("事件触发线程---控制事件循环")]),v._v(" "),l("li",[v._v("定时器线程")]),v._v(" "),l("li",[v._v("异步 HTTP 请求线程")])])])]),v._v(" "),l("h3",{attrs:{id:"线程关系"}},[v._v("线程关系")]),v._v(" "),l("ul",[l("li",[v._v("浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。")]),v._v(" "),l("li",[v._v("DOM是属于渲染引擎中的东⻄，⽽JS⼜是JS引擎中的东⻄。当我们通过JS操作DOM的时候，就涉及到了两个线程之间的通信，那么势必会带来⼀些性能上的损耗。操作DOM次数⼀多，也就等同于⼀直在进⾏线程之间的通信，并且操作DOM可能还会带来重绘回流的情况，所以也就导致了性能上的问题。")]),v._v(" "),l("li",[v._v("由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。")]),v._v(" "),l("li",[v._v("单独的 iframe 会在单独的进程中运行")])]),v._v(" "),l("h3",{attrs:{id:"script、style-是否阻塞-html-解析与渲染"}},[v._v("script、style 是否阻塞 HTML 解析与渲染")]),v._v(" "),l("ul",[l("li",[v._v("style 阻塞 HTMl 的渲染，不阻塞解析")]),v._v(" "),l("li",[v._v("script，会阻碍 HTMl 的解析，下载好并执行完脚本才会继续解析")]),v._v(" "),l("li",[v._v("async script，解析的过程中，脚本异步下载，下载完立即执行，也会阻碍 HTML 的解析")]),v._v(" "),l("li",[v._v("defer script，不会阻碍 HTML 的解析，解析完再按照顺序执行脚本")])])])}),[],!1,null,null,null);_.default=i.exports}}]);