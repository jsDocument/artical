(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{257:function(v,_,e){"use strict";e.r(_);var a=e(6),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"http-请求过程"}},[v._v("HTTP 请求过程")]),v._v(" "),e("ul",[e("li",[v._v("这个请求指的是 http 请求，当一个请求从客户端发出去之后，服务器端收到请求后，一个请求过程就结束了，这时就算是客户端abort这个请求，服务器端仍会做出完整的响应，只是这个响应客户端不会接收。所以实质上，后端还是处理了请求，但是前端不对该方法进行处理。")]),v._v(" "),e("li",[v._v("cacheables：优雅、支持不同缓存策略、没有依赖、体积小、适用xx、辅助函数来构建缓存 key\n"),e("ul",[e("li",[v._v('cache.cacheable(() => fetch("https://some-url.com/api"), "key");')]),v._v(" "),e("li",[v._v("delete, clear")]),v._v(" "),e("li",[v._v("keys")]),v._v(" "),e("li",[v._v("isCached")]),v._v(" "),e("li",[v._v("cacheables.key")])])])]),v._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 实例")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" cache "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Cacheables")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[v._v("logTiming")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[v._v("log")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),e("ul",[e("li",[v._v("HTTP 缓存分类：\n"),e("ul",[e("li",[v._v("按缓存位置：service worker, memory cache, disk cache(HTTP cache), 网络请求\n"),e("ul",[e("li",[v._v("memory cache: 关闭 Tab 则缓存清除, preloader请求的资源会被放入 memory cache 中; preload 显式的预加载资源也会被放入 memory cache 中")]),v._v(" "),e("li",[v._v("memory cache 可以保证相同的资源地址多次请求，只请求最多一次")]),v._v(" "),e("li",[v._v("disk cache: 持久缓存，会严格根据 HTTP 头信息中的各类字段判定资源状态，是否是可用缓存，是否过时，命中从磁盘缓存读取资源")])])]),v._v(" "),e("li",[v._v("按失效策略：属于 disk cache；cache-control, ETag")])])]),v._v(" "),e("li",[v._v("cache-control: max-age, public, private代理服务器不能缓存, no-cache 客户端缓存了内容，是否使用内容由后续的对比决定, no-store")]),v._v(" "),e("li",[v._v("max-age:0, must-revalidate 和 no-cache 大致上是一致的")]),v._v(" "),e("li",[v._v("强制缓存：直接减少请求数，提升最大的缓存策略；字段 Cache-control和 Expirs-----配合文件 Hash 使用\n"),e("ul",[e("li",[v._v("Expirs, HTTP1.0字段，缓存到期时间(绝对时间)，用户在客户端本地的时间进行修改，会造成浏览器缓存失效，时差和误差也会导致缓存失效；写法也复杂")]),v._v(" "),e("li",[v._v("Cache-control，max-age 最大缓存时间(相对时间)，must-revalidate 超过时间，浏览器必须向服务器发送请求，验证资源是否还有效")])])]),v._v(" "),e("li",[v._v("协商缓存：\n"),e("ul",[e("li",[v._v("流程：浏览器请求缓存数据库，返回一个"),e("code",[v._v("缓存标识")]),v._v("；之后浏览器用这个标识和服务器通信，如果缓存未失效，返回 304表示继续使用，客户端继续使用缓存（使用什么缓存？），如果失效，则返回新数据和规则，浏览器响应后再把规则写入缓存数据库。")]),v._v(" "),e("li",[v._v("强制缓存失效(超出规定时间)时，需要使用对比缓存，由服务器决定是否使用缓存内容，协商缓存和没有缓存在请求数上是一样的，但仅返回状态码304，在响应体积上优化了")]),v._v(" "),e("li",[v._v("last-modifed: 服务器通过改自动告知客户端，资源最后一次被修改的时间，浏览器将这个值和内容一起记录在缓存数据库中，下次请求相同资源时，将 If-Modified-Since: last-modified的值写入到请求头，和服务器中文件的最后修改时间进行对比。(只能精确到秒，不适合短时间内频繁改动的资源，也可能出现资源内容没有改变，而 Last-Modified 改变的情况)")]),v._v(" "),e("li",[v._v("If-Modified-Since 缓存校验字段，值为资源最后一次修改的时间")]),v._v(" "),e("li",[v._v("ETag：唯一标识请求资源的字符串(hash)，更加 ETag 的值缓存数据")]),v._v(" "),e("li",[v._v("If-Match：缓存校验字段，值为唯一标识请求资源的字符串，即 ETag 的值；If-None-Match")])])]),v._v(" "),e("li",[v._v("ETag 生成条件\n"),e("ul",[e("li",[v._v("文件更改时，ETag 值必须改版")]),v._v(" "),e("li",[v._v("必须横向扩展，分布式部署时多个服务器节点上生成的 ETag 值保持一致")]),v._v(" "),e("li",[v._v("尽量便于计算，不会特别耗 CPU")]),v._v(" "),e("li",[v._v("Nginx 的 ETag: Last-Modified + Content-Length<mtime, ctime>\n"),e("ol",[e("li",[v._v("如果1s 内修改了文件并且保持文件大小不变，就存在问题")]),v._v(" "),e("li",[v._v("如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改？不一定，有服务器 ETag生成算法决定")]),v._v(" "),e("li",[v._v("Last-Modified 变了，但是 Content-Length 没变（文件内容不变），是否意味着 etag 的缓存失效？")])])])])])]),v._v(" "),e("ol",[e("li",[v._v("webpack-runtime")]),v._v(" "),e("li",[v._v("react-chunk")]),v._v(" "),e("li",[v._v("vender")]),v._v(" "),e("li",[v._v("echarts")]),v._v(" "),e("li",[v._v("page")]),v._v(" "),e("li",[v._v("用的的配置：\n"),e("ol",[e("li",[v._v("splitChunk")]),v._v(" "),e("li",[v._v("runtimeChunk")])])])]),v._v(" "),e("p",[v._v("总结：")]),v._v(" "),e("hr"),v._v(" "),e("ol",[e("li",[v._v("调用 Service Worker 的 fetch 事件响应")]),v._v(" "),e("li",[v._v("查看 memory cache")]),v._v(" "),e("li",[v._v("查看 disk cache。这里又细分：\n"),e("ol",[e("li",[v._v("如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200")]),v._v(" "),e("li",[v._v("如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200")])])]),v._v(" "),e("li",[v._v("发送网络请求，等待网络响应")]),v._v(" "),e("li",[v._v("把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)")]),v._v(" "),e("li",[v._v("把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)")]),v._v(" "),e("li",[v._v("把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("请求字段")]),v._v(" "),e("ul",[e("li",[v._v("Host 是必须的吗？必须，因为不知道会不会途径代理")]),v._v(" "),e("li",[v._v("Accept-Encoding 通知服务器可接受的编码(如："),e("code",[v._v("gzip")]),v._v(", compress, deflate, identity不进行编码)；")]),v._v(" "),e("li",[v._v("Transfer-Encoding 传送报文实体时采用的编码")]),v._v(" "),e("li",[v._v("Accept-Language 语言；Accept-Charset 优先字符集；")]),v._v(" "),e("li",[v._v("Authorization 告诉服务器用户代理的认证信息, Proxy-Authorization 代理服务器认证所需要的信息")]),v._v(" "),e("li",[v._v("Range 部分资源的范围请求")]),v._v(" "),e("li",[v._v("Accept-Range: bytes 接受字节范围")]),v._v(" "),e("li",[v._v("Connection: keep-Alive")]),v._v(" "),e("li",[v._v("Max-Forward 最大转发次数")]),v._v(" "),e("li",[e("code",[v._v("X-Forward-For")]),v._v(" 被反向代理生成")]),v._v(" "),e("li",[v._v("Last-Modified 资源最后修改日期")]),v._v(" "),e("li",[v._v("Expires 实体主体过期的日期时间")]),v._v(" "),e("li",[v._v("ETag 资源的匹配信息")]),v._v(" "),e("li",[v._v("If-Match 匹配实体资源标记值(ETag)")]),v._v(" "),e("li",[v._v("Pragma: no-cache")]),v._v(" "),e("li",[v._v("Location 令客户端重定向到指定URI")]),v._v(" "),e("li",[e("code",[v._v("Vary")]),v._v(": Accept-Encoding 缓存管理信息")]),v._v(" "),e("li",[v._v("Content-Type: application/octet-stream 二进制流")]),v._v(" "),e("li",[v._v("Content-Length，Content-Range,")]),v._v(" "),e("li",[v._v("Content-Encoding: "),e("code",[v._v("gzip")]),v._v(" 确保开启了")]),v._v(" "),e("li",[v._v("Content-Language")]),v._v(" "),e("li",[e("code",[v._v("Connection")]),v._v(" 连接状态(keep-alive，close) 管理持久链接，不再转发给代理服务器的首部字段。")]),v._v(" "),e("li",[v._v("Date HTTP创建报文的日期和时间")]),v._v(" "),e("li",[v._v("Via 代理服务器相关信息")]),v._v(" "),e("li",[v._v("X-Powered-By 与 Server 可知道对方的技术栈")]),v._v(" "),e("li",[e("code",[v._v("referer")]),v._v(" 用于打点 或 防盗链")])])]),v._v(" "),e("li",[e("p",[v._v("UDP与TCP基本区别")]),v._v(" "),e("ol",[e("li",[v._v("TCP要求系统资源较多，面UDP较少")]),v._v(" "),e("li",[v._v("TCP采用"),e("code",[v._v("流模式")]),v._v("，UDP采用"),e("code",[v._v("数据报模式")])]),v._v(" "),e("li",[v._v("TCP保证数据的正确性，UDP可能丢包")]),v._v(" "),e("li",[v._v("TCP保证数据顺序，UDP不保证")]),v._v(" "),e("li",[v._v("使用时socket()参数不同")])])]),v._v(" "),e("li",[e("p",[v._v("过程")]),v._v(" "),e("ol",[e("li",[v._v("应用层(HTTP数据)【发送端】")]),v._v(" "),e("li",[v._v("传输层(TCP首部 + HTTP数据)")]),v._v(" "),e("li",[v._v("网络层(IP首部 + TCP首部 + HTTP数据)")]),v._v(" "),e("li",[v._v("链路层(以太网首部 + IP首部 + TCP首部 + HTTP数据)")]),v._v(" "),e("li",[v._v("接受端再一层层把对应的首部消去")])])]),v._v(" "),e("li",[e("p",[v._v("DNS")]),v._v(" "),e("ul",[e("li",[v._v("客户端向DNS进行域名查询请求，DNS服务器告知客户端Web服务器的IP地址，客户端与服务器进行通信")]),v._v(" "),e("li",[v._v("如果域名正好被服务器缓存，那么直接返回，否则要根据是几级域名，进行查找。")])])]),v._v(" "),e("li",[e("p",[v._v("GET 与 POST")]),v._v(" "),e("ol",[e("li",[v._v("浏览器返回，是否会再次请求？是否会被浏览器主动 cache? 是否只支持 url 编码？请求参数是否会被完整的保存在浏览器历史记录里？请求参数长度限制？参数类型只支持 ASCII？")]),v._v(" "),e("li",[v._v("产生几个数据包？")]),v._v(" "),e("li",[v._v("GET请求的数据会附在URL之后，而POST提交的数据 是在HTTP包的包体中")]),v._v(" "),e("li",[v._v("传输数据大小不同")]),v._v(" "),e("li",[v._v("安全性不同，通过GET提交的数据，会明文出现在URL上")]),v._v(" "),e("li",[v._v("GET请求是幂等性的，所以不能用GET请求做数据的增删改有副作用的操作；因为是幂等的，在网络不好的隧道中会尝试重试，用GET请求可能会造成重复操作。")])])]),v._v(" "),e("li",[e("p",[v._v("ARP 解析地址的协议，可以通过IP地址反查出对应的MAC地址")])]),v._v(" "),e("li",[e("p",[v._v("CONNECT 使用隧道协议进行TCP通信，主要使用SSL(安全套接层)和TLS(传输层安全)协议把通信内容加密后以过网络隧道传输")])]),v._v(" "),e("li",[e("p",[v._v("持久链接：keep-alive, 管线化")])])]),v._v(" "),e("p",[v._v("GET 在浏览器回退时是无害的，而 POST 会再次提交请求。")]),v._v(" "),e("p",[v._v("GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。")]),v._v(" "),e("p",[v._v("GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。")]),v._v(" "),e("p",[v._v("GET 请求只能进行 url 编码，而 POST 支持多种编码方式。")]),v._v(" "),e("p",[v._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。")]),v._v(" "),e("p",[v._v("GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。")]),v._v(" "),e("p",[v._v("对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。")]),v._v(" "),e("p",[v._v("GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。")]),v._v(" "),e("p",[v._v("GET 参数通过 URL 传递，POST 放在 Request body 中。")]),v._v(" "),e("p",[v._v("GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。")])])}),[],!1,null,null,null);_.default=t.exports}}]);