(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{159:function(e,i,t){"use strict";t.r(i);var l=t(0),n=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,i=e.$createElement,t=e._self._c||i;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"transition实现讲解"}},[e._v("transition实现讲解")]),t("h2",{attrs:{id:"transition-被指令transition所使用"}},[e._v("transition 被指令transition所使用")]),t("p",[e._v("在指令update(id, oldId)时, 获取options中配置的transitions钩子方法, el.__v_trans为其Transition实例, oldId存在时移除el上的class: oldId = '-transition'; 否则添加class: id+ '-transition'")]),t("ul",[t("li",[e._v("applyTransition(el, direction, op, vm, cb)\n"),t("ol",[t("li",[e._v("el.transition不存在时, 执行op(append, before, remove), cb存在则执行")]),t("li",[e._v("否则执行transion相应的enter或leave方法")])])]),t("li",[e._v("appendWithTransition(el, target, vm, cb)")]),t("li",[e._v("beforeWithTransition(el, target, vm, cb)")]),t("li",[e._v("removeWithTransition(el, target, vm, cb)")])]),t("h2",{attrs:{id:"transition-el-id-hooks-vm-类"}},[e._v("Transition(el, id, hooks, vm)类")]),t("ul",[t("li",[t("p",[e._v("初始化实例属性: id, el, enterClass/leaveClass, hooks, type, pendingCssEvent, pendingCssCb, cancle, pendingJsCb为动作结束回调与取消操作, op, cb, justEntered, entered, left, typeCache")])]),t("li",[t("p",[e._v("定义enterNextTick, enterDone, leaveNextTick, leaveDone属性方法绑定上下文为当前实例")])]),t("li",[t("p",[e._v("cancelPending 取消正在执行的动画, css动画则解绑事件, 置空事件与回调, js动画则调用回调的取消方法与置空回调; 去除el的相应class, 执行this.cancel方法")]),t("ol",[t("li",[e._v("实例属性op, cb = null; hasPending = false")]),t("li",[e._v("this.pendingCssCb, 解绑this.pendingCssEvent事件的this.pendingCssCb 并将其置为null, hasPending = true;")]),t("li",[e._v("this.pendingJsCb, 将其取消this.pendingJsCb.cancel(), 并置为null, hasPending = true;")]),t("li",[e._v("hasPending时， 移除el相应的this.enterClass与this.leaveClass")]),t("li",[e._v("this.cancel存在, 执行并置为null")])])]),t("li",[t("p",[e._v("enter(op, cb) 动作进入")]),t("ol",[t("li",[e._v("cancelPending(),  取消正在执行的动画")]),t("li",[e._v("调用beforeEnter钩子函数")]),t("li",[e._v("更新this.cb = cb, el元素上添加this.enterClass")]),t("li",[e._v("执行op(), 即执行相应的DOM操作")]),t("li",[e._v("this.entered = false,")]),t("li",[e._v("执行钩子callHookWithCb('enter'), 判断transitions.hooks中是否定义了该类开的js回调, 定义了则执行")]),t("li",[e._v("this.cancel更新为this.hooks.enterCancelled")]),t("li",[e._v("将this.enterNextTick 更新到队列: pushJob()")])])]),t("li",[t("p",[e._v("getCssTransitionType(className)  获取动画类型")]),t("ol",[t("li",[e._v("'transitionEnd' 事件不存在 或 document.hidden 或 this.hooks.css 等于false, this.el为hidden时, 返回")]),t("li",[e._v("根据this.el.style 或 window.getComputedStyle(this.el) 获取行内样式与计算样式的transition属性")]),t("li",[e._v("如果transitionDuration不为0时, 更新type = 'transition'")]),t("li",[e._v("如果animationDuration不为0时, 更新type = 'animation'")]),t("li",[e._v("根据className缓存类型并返回")])])]),t("li",[t("p",[e._v("setupCssCb(event, cb) 定义动画事件回调, 绑定动画事件回调")]),t("ol",[t("li",[e._v("this.pendingCssEvent = event,")]),t("li",[e._v("定义onEnd = this.pendingCssCb 为 e.target === self.el时, 解绑event的onEnd, self.pendingCssEvent与self.pendingCsscb = null, !self.pendingJsCb 且 cb存在则执行cb")]),t("li",[e._v("绑定el, event事件, onEnd回调")])])]),t("li",[t("p",[e._v("enterNextTick 添加动作结束的事件监听或执行结束动画")]),t("ol",[t("li",[e._v("this.justEntered = true, 定时更新该属性为false")]),t("li",[e._v("获取动画类型type")]),t("li",[e._v("如果不存在this.pendingJsCb 如果类型为为transition动画, 则移除this.enterClass, 安装动作结束事件的回调enterDone, 如果animation动画类型时, 安装动画结束的事件回调enterDone, 否则调用enterDone()")]),t("li",[e._v("类型为transition时, 移除this.enterClass")])])]),t("li",[t("p",[e._v("enterDone 动画结束的操作")]),t("ol",[t("li",[e._v("this.entered = true")]),t("li",[e._v("this.cancel = this.pendingJsCb = null")]),t("li",[e._v("移除this.enterClass")]),t("li",[e._v("执行afterEnter钩子, this.cb存在则执行this.cb()")])])]),t("li",[t("p",[e._v("leave(op, cb)")]),t("ol",[t("li",[e._v("this.cancelPending(), 执行beforeLeave钩子函数,  this.op = op, this.cb = cb")]),t("li",[e._v("添加this.leaveClass, this.left = false")]),t("li",[e._v("执行this.callHookWithCb('leave')")]),t("li",[e._v("取this.calcel")]),t("li",[e._v("如果this.op与!this.pendingJsCb时, 如果this.justEntered则执行this.leaveDone(), 即enter未执行即事时触发leave, 则让leave结束; 更新this.leaveNextTick队列 pushJob()")])])]),t("li",[t("p",[e._v("leaveNextTick")]),t("ol",[t("li",[e._v("获取动画类型")]),t("li",[e._v("执行安装动画结束事件回调 或 this.leaveDone()")])])]),t("li",[t("p",[e._v("leaveDone")]),t("ol",[t("li",[e._v("this.left = true, this.canel = this.pendingJsCb = null")]),t("li",[e._v("this.op() 相应的dom操作")]),t("li",[e._v("移除this.leaveClass")]),t("li",[e._v("执行afterLeave钩子函数")]),t("li",[e._v("this.cb存在则执行this.cb()")]),t("li",[e._v("this.op = null")])])]),t("li",[t("p",[e._v("callHookWithCb(type)")]),t("ol",[t("li",[e._v("取this.hooks[type]钩子hook, hook长度大于1, 更新this.pendingJsCb = cancellable(this[type = 'Done']) 即定义动画结束与取消的方法")]),t("li",[e._v("执行hook.call(this.vm, this.el, this.pendingJsCb)")])])]),t("li",[t("p",[e._v("callHook(type)")]),t("ol",[t("li",[e._v("取this.hooks[type]钩子存在则执行。")])])]),t("li",[t("p",[e._v("isHidden 判断元素el.offsetWidth, el.offsetHight, el.getClientRects().length")])]),t("li",[t("p",[e._v("cancellable(fn) 定义cb函数, 判断!cb.cancelled 以当前上下文与参数执行fn; 再定义cb.cancel方法, 更新cb.cancelled = true。")])]),t("li",[t("p",[e._v("pushJob(job)")]),t("ol",[t("li",[e._v("job更新到queue数组")]),t("li",[e._v("!queued, queued = true, nextTick(flush)")])])]),t("li",[t("p",[e._v("flush")]),t("ol",[t("li",[e._v("循环queue并执行")]),t("li",[e._v("queue = [], queued = false")]),t("li",[e._v("返回document.documentElement.offsetHeight")])])])])])}],!1,null,null,null);i.default=n.exports}}]);