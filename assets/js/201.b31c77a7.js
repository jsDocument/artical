(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{390:function(t,e,i){"use strict";i.r(e);var n=i(0),v=Object(n.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[i("ul",[i("li",[t._v("nextTick 原理：\n"),i("ul",[i("li",[t._v("callbacks数组用来存储 nextTick")]),t._v(" "),i("li",[t._v("Promise.then、MutationObserve、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件")]),t._v(" "),i("li",[t._v("push到当前这一次事件循环的microtask队列末尾，因为微任务会在这次事件结束前执行")]),t._v(" "),i("li",[t._v("task则会push到task队列末尾，可能需要等待多次事件循环才后执行（取决于task队列的长度），等待时间较长。")]),t._v(" "),i("li",[t._v("每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run")])])]),t._v(" "),i("li",[t._v("v-if, v-show, v-html 的实现原理\n"),i("ul",[i("li",[t._v("v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；")]),t._v(" "),i("li",[t._v("v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；")]),t._v(" "),i("li",[t._v("v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值")])])]),t._v(" "),i("li",[t._v("Vue 中的 computed 和 watch 的区别在哪里\n"),i("ul",[i("li",[t._v("watch 会生成一个watcher对象，在监视的属性每次变动时都会触发回调")]),t._v(" "),i("li",[t._v("computed则是生成一个惰性的watcher，只有在取值操作(getter触发)时收集依赖且计算值，当有依赖变动时仅将 dirty 置为 true，不做计算操作，当有取值操作时，根据自身标记 dirty 属性返回上一次计算结果/重新计算值")])])]),t._v(" "),i("li",[t._v("computed 的实现原理")])])])}],!1,null,null,null);e.default=v.exports}}]);