(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{319:function(e,a,r){"use strict";r.r(a);var t=r(0),i=Object(t.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"through2是对stream-transform的封装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#through2是对stream-transform的封装"}},[e._v("#")]),e._v(" through2是对stream.Transform的封装")]),e._v(" "),r("h2",{attrs:{id:"api基础回顾"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#api基础回顾"}},[e._v("#")]),e._v(" API基础回顾")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("stream.Readable---_read(size) "),r("code",[e._v("两种模式(flowing, paused)、三种状态、选择一种方法: 停止必调用read方法从流中读取数据片段、 读、恢复、包裹、头部增加")])]),e._v(" "),r("blockquote",[r("p",[e._v("可读流都始于paused模式；通过data事件、resume方法，pipe方法发送数据到可定流；将paused模式切换到flowing模式，如果没有管道目标，可以通过pause方法切换回paused模式，有管道目标，则移除管道目标，或调用unpipe方法移除多个管道目标，回到paused模式")])]),e._v(" "),r("ul",[r("li",[e._v("事件：close, data, end, error, readable")]),e._v(" "),r("li",[e._v("方法：destory(), isPaused(), paused(), pipe(), read(), resume(), setEncoding(), unpipe(), unshift(), wrap(), readable"),r("a",{attrs:{href:""}},[e._v("Symbol.asynclterator")])]),e._v(" "),r("li",[e._v("属性：readableHighWaterMark, readableLength")])])]),e._v(" "),r("li",[r("p",[e._v("stream.Writable---_write(chunk, encoding, callback)")]),e._v(" "),r("ul",[r("li",[e._v("事件：close, drain「write方法返回false时」, error, finish, pipe「流到目标流时触发」, unpipe「可读流调用unpipe方法，从目标流中移除当前可写流时触发」")]),e._v(" "),r("li",[e._v("方法：cork()「强制把所有写入的数据都缓存到内存中」, destory(), end()「被缓冲的数据输出」, setDefaultEncoding(), uncork()「cork缓冲的数据输出」, write()")]),e._v(" "),r("li",[e._v("属性：writableHighWaterMark, writableLength")])])]),e._v(" "),r("li",[r("p",[e._v("stream.Duplex---_read(size) 和 _write(chunk, encoding, callback) 写与读无关联，两个缓冲区互不干扰")])]),e._v(" "),r("li",[r("p",[e._v("stream.Transform---_flush(size) 和 _transform(chunk, encoding, callback)  输入与输出存在相互关联")]),e._v(" "),r("ul",[r("li",[e._v("destory()")])])]),e._v(" "),r("li",[r("p",[e._v("公共方法：finished(), pipeline()")])])]),e._v(" "),r("blockquote",[r("p",[e._v("缓冲区：每个缓冲区都有一个highWaterMark的阈值，超过后会停止读或写操作。")])]),e._v(" "),r("h2",{attrs:{id:"stream-实现流的api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stream-实现流的api"}},[e._v("#")]),e._v(" stream 实现流的API")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("new stream.Writable([options]) 需要实现的方法")]),e._v(" "),r("ul",[r("li",[e._v("writable._write(chunk, encoding, callback)")]),e._v(" "),r("li",[e._v("writable._writev(chunks, callback)")]),e._v(" "),r("li",[e._v("writable._destroy(err, callback)")]),e._v(" "),r("li",[e._v("writable._final(callback)")])])]),e._v(" "),r("li",[r("p",[e._v("new stream.Readable([options])")]),e._v(" "),r("ul",[r("li",[e._v("readable._read(size)")]),e._v(" "),r("li",[e._v("readable._destroy(err, callback)")]),e._v(" "),r("li",[e._v("readable.push(chunk[, encoding])")])])]),e._v(" "),r("li",[r("p",[e._v("new stream.Duplex([options])")])]),e._v(" "),r("li",[r("p",[e._v("new stream.Transform([options])")]),e._v(" "),r("ul",[r("li",[e._v("事件finish, end")]),e._v(" "),r("li",[e._v("transform._flush(callback)")]),e._v(" "),r("li",[e._v("transform._transform(chunk, encoding, callback)")])])])])])}],!1,null,null,null);a.default=i.exports}}]);