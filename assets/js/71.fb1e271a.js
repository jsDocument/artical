(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{261:function(v,_,l){"use strict";l.r(_);var i=l(6),T=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("ul",[l("li",[v._v("二进制分帧")]),v._v(" "),l("li",[v._v("请求多路复用")]),v._v(" "),l("li",[v._v("头部压缩:  HPack使用哈夫曼编码和索引表实现，需要客户端和服务器都维护一个"),l("code",[v._v("表头字段的索引表")])]),v._v(" "),l("li",[v._v("服务器推送：有服务器根据解析 index.html 同事推送资源信息")]),v._v(" "),l("li",[v._v("赋予请求优先级")]),v._v(" "),l("li",[v._v("Curl 不支持 HTTP2")]),v._v(" "),l("li",[v._v("头阻塞：出现在 TCP 层？ HTTP/2 多路复用的并行特性对于 TCP 的丢包恢复机制是不可见的，一个丢失或顺序不对的数据包会导致所有活动的事务停顿，无论其是否受到丢包的直接影响。因为 HTTP2 开了太多并行的 TCP 连接")]),v._v(" "),l("li",[v._v("距离远？丢包可能性更大？")])]),v._v(" "),l("p",[v._v("为什么 HTTP1.1 没有办法实现多路复用？")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("HTTP1.1为什么没有多路复用：HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。")])]),v._v(" "),l("li",[l("p",[v._v("HTTP的缺点")]),v._v(" "),l("ol",[l("li",[v._v("通信使用明文，可能会被窃听")]),v._v(" "),l("li",[v._v("不验证通信方的身份，可能遭遇伪装----查证书")]),v._v(" "),l("li",[v._v("无法证明报文的完整性，可能被篡改----数字签名校验")]),v._v(" "),l("li",[v._v("可通过SSL或TLS的组合使用，加密HTTP的通信内容，即HTTPS")]),v._v(" "),l("li",[v._v("HTTP是无状态协议：通过 Cookie 标识")])])]),v._v(" "),l("li",[l("p",[v._v("HTTP3 标准跟踪 RFC---QUIC通用的传输协议：包含流的复用和对每个流的流量控制，这两者与 HTTP/2 中实现的类似。通过在整个连接中提供流级别的可靠性和拥塞控制，比起 TCP 映射，QUIC 更能提高 HTTP 的性能")])]),v._v(" "),l("li",[l("p",[v._v("支持 0-RTT QUIC 连接，减少了建立安全 TLS 连接的数据往返次数。")])]),v._v(" "),l("li",[l("p",[v._v("HTTPS 主要解决的三个安全问题---握手过程主要是和服务器做通讯，生成"),l("code",[v._v("私有秘钥")]),v._v("，最后通过该秘钥"),l("code",[v._v("对称加密传输数据")]),v._v("。还有"),l("code",[v._v("验证证书")]),v._v("的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。")]),v._v(" "),l("ul",[l("li",[v._v("内容隐私")]),v._v(" "),l("li",[v._v("防篡改")]),v._v(" "),l("li",[v._v("确认对方身份")]),v._v(" "),l("li",[v._v("TLS----SSL 协商")])])]),v._v(" "),l("li",[l("p",[v._v("TCP 传输层")]),v._v(" "),l("ol",[l("li",[v._v("对数据进行"),l("code",[v._v("分割")]),v._v("，打上"),l("code",[v._v("标记序号及端口号")]),v._v("，发送给网络层；")]),v._v(" "),l("li",[v._v("(IP)网络层"),l("code",[v._v("增加MAC地址")]),v._v("后转发给链路层")]),v._v(" "),l("li",[v._v("三次握手策略：数据发送出去后，会向对应确认是否已送达，过程中使用的TCP的flag---"),l("code",[v._v("SYN和ACK")]),v._v(" "),l("ul",[l("li",[v._v("发送端发送一个带"),l("code",[v._v("SYN标志")]),v._v("(建立联机)的数据包给对方----建立")]),v._v(" "),l("li",[v._v("接收端收到后回传一个"),l("code",[v._v("SYN/ACK标志")]),v._v("(确认：原SYN+1)的数据包以示传达确认信息-----传达确认")]),v._v(" "),l("li",[v._v("最后发送端再回传一个带"),l("code",[v._v("ACK+1")]),v._v("标志的数据包；以示结束。-----确认收到")])])]),v._v(" "),l("li",[v._v("四次挥手\n"),l("ul",[l("li",[v._v("客户端发送一个"),l("code",[v._v("FIN标记")]),v._v("(结束)的数据包到服务端")]),v._v(" "),l("li",[v._v("服务端收到后再返回一个"),l("code",[v._v("ACK标志")]),v._v("的数据包回来")]),v._v(" "),l("li",[l("code",[v._v("服务器端关闭")]),v._v("与客户端的连接，再发送一个"),l("code",[v._v("FIN给到客户端")])]),v._v(" "),l("li",[v._v("客户端再发回ACK的数据包确认")])])])])]),v._v(" "),l("li",[l("p",[v._v("其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。")])]),v._v(" "),l("li",[l("p",[l("a",{attrs:{href:"TSL.png"}},[v._v("TLS 握手过程")])])]),v._v(" "),l("li",[l("p",[v._v("wireshark 抓包 https/http2")])]),v._v(" "),l("li",[l("p",[v._v("http3，基于 UDP，解决了对头阻塞与 TCP 和 TLS握手时的延迟问题")])])])])}),[],!1,null,null,null);_.default=T.exports}}]);