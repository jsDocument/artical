(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{109:function(e,n,t){"use strict";t.r(n);var r=[function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"watch"}},[this._v("watch")]),n("p",[n("img",{attrs:{src:t(44),alt:"流程 text",title:"title"}})]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("\nlet uid = 0\n\n/**\n* 监听表达式, 收集依赖, 当表达式值改变时触发callback\n* @param {Vue} vm\n* @param {String} expression\n* @param {Function} cb\n* @param {Object} options\n*                 - {Array} filters\n*                 - {Boolean} twoWay\n*                 - {Boolean} deep\n*                 - {Boolean} user\n*                 - {Boolean} sync  异步\n*                 - {Boolean} lazy  延迟\n*                 - {Function} [preProcess]\n*                 - {Function} [postProcess]\n* @constructor\n*/\n\nexport default function Watcher (vm, expOrFn, cb, options) {\n// mix in options\nif (options) {\n  extend(this, options)\n}\nvar isFn = typeof expOrFn === 'function'\nthis.vm = vm\n// 更新Vue当中_watchers\nvm._watchers.push(this)\nthis.expression = isFn ? expOrFn.toString() : expOrFn\nthis.cb = cb\nthis.id = ++uid // uid for batching\nthis.active = true   // 是否存在\nthis.dirty = this.lazy // lazy watcher是否已获取数据, 未获取为true\nthis.deps = Object.create(null)\nthis.newDeps = null\nthis.prevError = null // 异步错误堆栈\n// parse expression for getter/setter\nif (isFn) {\n  this.getter = expOrFn\n  this.setter = undefined\n} else {\n  // 解析表达式, 获取其get与set\n  var res = parseExpression(expOrFn, this.twoWay)\n  this.getter = res.get\n  this.setter = res.set\n}\n// 是否延迟获取值\nthis.value = this.lazy\n  ? undefined\n  : this.get()\n// 初始化数据时, 监听调用vm._digest(true)避免触发\n// state for avoiding false triggers for deep and Array\n// watchers during vm._digest()\nthis.queued = this.shallow = false  // 是否为深度更新\n}\n\n/**\n* Add a dependency to this directive.\n* 添加一个dep到当前实例属性队列, 同时更新dep属性队列中的watcher实例\n* @param {Dep} dep\n*/\n\nWatcher.prototype.addDep = function (dep) {\nvar id = dep.id\nif (!this.newDeps[id]) {\n  this.newDeps[id] = dep\n  if (!this.deps[id]) {\n    this.deps[id] = dep\n    dep.addSub(this)\n  }\n}\n}\n\n/**\n* Dep.target指向当前实例, 创建newDeps对象\n*/\n\nWatcher.prototype.beforeGet = function () {\nDep.target = this\nthis.newDeps = Object.create(null)\n}\n\n/**\n* Evaluate the getter, and re-collect dependencies.\n*/\n\nWatcher.prototype.get = function () {\n// 更新Dep.target 与 创建newDeps\nthis.beforeGet()\nvar scope = this.scope || this.vm\nvar value\n// 执行getter获取值\ntry {\n  value = this.getter.call(scope, scope)\n} catch (e) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    config.warnExpressionErrors\n  ) {\n    warn(\n      'Error when evaluating expression \"' +\n      this.expression + '\". ' +\n      (config.debug\n        ? ''\n        : 'Turn on debug mode to see stack trace.'\n      ), e\n    )\n  }\n}\n// \"touch\" every property so they are all tracked as\n// dependencies for deep watching\nif (this.deep) {\n  traverse(value)\n}\n// 执行value预处理\nif (this.preProcess) {\n  value = this.preProcess(value)\n}\n// 执行filters\nif (this.filters) {\n  value = scope._applyFilters(value, null, this.filters, false)\n}\n// 结束处理\nif (this.postProcess) {\n  value = this.postProcess(value)\n}\nthis.afterGet()\nreturn value\n}\n\n/**\n* Recrusively traverse an object to evoke all converted\n* getters, so that every nested property inside the object\n* is collected as a \"deep\" dependency.\n*\n* @param {*} val\n*/\n\nfunction traverse (val) {\nvar i, keys\nif (isArray(val)) {\n  i = val.length\n  while (i--) traverse(val[i])\n} else if (isObject(val)) {\n  keys = Object.keys(val)\n  i = keys.length\n  while (i--) traverse(val[keys[i]])\n}\n}\n\n/**\n* Clean up for dependency collection.\n* 清除依赖集合, 根据newDeps更新deps集合\n*/\n\nWatcher.prototype.afterGet = function () {\nDep.target = null\nvar ids = Object.keys(this.deps)\nvar i = ids.length\nwhile (i--) {\n  var id = ids[i]\n  if (!this.newDeps[id]) {\n    this.deps[id].removeSub(this)\n  }\n}\nthis.deps = this.newDeps\n}\n\n/**\n* Set the corresponding value with the setter.\n*\n* @param {*} value\n*/\n\nWatcher.prototype.set = function (value) {\nvar scope = this.scope || this.vm\n// 执行filters\nif (this.filters) {\n  value = scope._applyFilters(\n    value, this.value, this.filters, true)\n}\n// 执行setter\ntry {\n  this.setter.call(scope, scope, value)\n} catch (e) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    config.warnExpressionErrors\n  ) {\n    warn(\n      'Error when evaluating setter \"' +\n      this.expression + '\"', e\n    )\n  }\n}\n// for循环时的指令实例\nvar forContext = scope.$forContext\nif (forContext && forContext.alias === this.expression) {\n  if (forContext.filters) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'It seems you are using two-way binding on ' +\n      'a v-for alias (' + this.expression + '), and the ' +\n      'v-for has filters. This will not work properly. ' +\n      'Either remove the filters or use an array of ' +\n      'objects and bind to object properties instead.'\n    )\n    return\n  }\n  forContext._withLock(function () {\n    if (scope.$key) { // original is an object\n      forContext.rawValue[scope.$key] = value\n    } else {\n      //\n      forContext.rawValue.$set(scope.$index, value)\n    }\n  })\n}\n}\n\n/**\n* 订单接口, 依赖发生改变时被调用\n* @param {Boolean} shallow\n*/\n\nWatcher.prototype.update = function (shallow) {\n// 延迟\nif (this.lazy) {\n  this.dirty = true\n// 同步\n} else if (this.sync || !config.async) {\n  this.run()\n} else {\n  // if queued, only overwrite shallow with non-shallow,\n  // but not the other way around.\n  this.shallow = this.queued\n    ? shallow\n      ? this.shallow\n      : false\n    : !!shallow\n  this.queued = true\n  // record before-push error stack in debug mode\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.debug) {\n    this.prevError = new Error('[vue] async stack trace')\n  }\n  // 更新watcher队列\n  pushWatcher(this)\n}\n}\n\n/**\n* Batcher job interface.\n* Will be called by the batcher.\n*/\n\nWatcher.prototype.run = function () {\nif (this.active) {\n  var value = this.get()\n  if (\n    value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated; but only do so if this is a\n    // non-shallow update (caused by a vm digest).\n    ((isObject(value) || this.deep) && !this.shallow)\n  ) {\n    // set new value\n    var oldValue = this.value\n    this.value = value\n    // in debug + async mode, when a watcher callbacks\n    // throws, we also throw the saved before-push error\n    // so the full cross-tick stack trace is available.\n    var prevError = this.prevError\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' &&\n        config.debug && prevError) {\n      this.prevError = null\n      try {\n        this.cb.call(this.vm, value, oldValue)\n      } catch (e) {\n        nextTick(function () {\n          throw prevError\n        }, 0)\n        throw e\n      }\n    } else {\n      this.cb.call(this.vm, value, oldValue)\n    }\n  }\n  this.queued = this.shallow = false\n}\n}\n\n/**\n* 计算watcher的值, lazy watcher, compute需计算时运用\n*/\n\nWatcher.prototype.evaluate = function () {\n// avoid overwriting another watcher that is being\n// collected.\nvar current = Dep.target\nthis.value = this.get()\nthis.dirty = false\nDep.target = current\n}\n\n/**\n* Depend on all deps collected by this watcher.\n*/\n\nWatcher.prototype.depend = function () {\nvar depIds = Object.keys(this.deps)\nvar i = depIds.length\nwhile (i--) {\n  this.deps[depIds[i]].depend()\n}\n}\n\n/**\n* Remove self from all dependencies' subcriber list.\n*/\n\nWatcher.prototype.teardown = function () {\nif (this.active) {\n  // remove self from vm's watcher list\n  // this is a somewhat expensive operation so we skip it\n  // if the vm is being destroyed or is performing a v-for\n  // re-render (the watcher list is then filtered by v-for).\n  if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n    this.vm._watchers.$remove(this)\n  }\n  var depIds = Object.keys(this.deps)\n  var i = depIds.length\n  while (i--) {\n    this.deps[depIds[i]].removeSub(this)\n  }\n  this.active = false\n  this.vm = this.cb = this.value = null\n}\n}\n\n\nVue.prototype.$watch = function (expOrFn, cb, options) {\n  var vm = this\n  var parsed\n  if (typeof expOrFn === 'string') {\n    parsed = parseDirective(expOrFn)\n    expOrFn = parsed.expression\n  }\n  var watcher = new Watcher(vm, expOrFn, cb, {\n    deep: options && options.deep,\n    sync: options && options.sync,\n    filters: parsed && parsed.filters,\n    user: !options || options.user !== false\n  })\n  if (options && options.immediate) {\n    cb.call(vm, watcher.value)\n  }\n  return function unwatchFn () {\n    watcher.teardown()\n  }\n}\n")])]),n("h2",{attrs:{id:"提供的几个方法-更新数据都会监听并通知进行watcher更新"}},[this._v("提供的几个方法, 更新数据都会监听并通知进行watcher更新")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("\n/**\n  * Intercept mutating methods and emit events\n  */\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n  * Swap the element at the given index with a new value\n  * and emits corresponding event.\n  *\n  * @param {Number} index\n  * @param {*} val\n  * @return {*} - replaced element\n  */\n\ndef(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = Number(index) + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n  * Convenience method to remove the element at given index.\n  *\n  * @param {Number} index\n  * @param {*} val\n  */\n\ndef(\n  arrayProto,\n  '$remove',\n  function $remove (item) {\n    /* istanbul ignore if */\n    if (!this.length) return\n    var index = indexOf(this, item)\n    if (index > -1) {\n      return this.splice(index, 1)\n    }\n  }\n)\n")])]),n("h2",{attrs:{id:"observer-利用object-defineproperty添加get与set-通过递归将甩有属性添加get与set"}},[this._v("observer 利用Object.defineProperty添加get与set, 通过递归将甩有属性添加get与set.")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("\nexport function defineReactive (obj, key, val) {\n  var dep = new Dep()\n\n  // cater for pre-defined getter/setters\n  var getter, setter\n  if (config.convertAllProperties) {\n    var property = Object.getOwnPropertyDescriptor(obj, key)\n    if (property && property.configurable === false) {\n      return\n    }\n    getter = property && property.get\n    setter = property && property.set\n  }\n\n  var childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val\n      // 判断是不是watcher.get调用\n      if (Dep.target) {\n        // dep更新到watcher的属性队列中\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i]\n            e && e.__ob__ && e.__ob__.dep.depend()\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val\n      if (newVal === value) {\n        return\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = observe(newVal)\n      // 进行赋值时会触发watcher更新\n      dep.notify()\n    }\n  })\n}\n  export function Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  def(value, '__ob__', this)\n  if (isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n// Instance methods\n\n/**\n  * Walk through each property and convert them into\n  * getter/setters. This method should only be called when\n  * value type is Object.\n  *\n  * @param {Object} obj\n  */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj)\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n  * Observe a list of Array items.\n  *\n  * @param {Array} items\n  */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i])\n  }\n}\n\n/**\n  * Convert a property into getter/setter so we can emit\n  * the events when the property is accessed/changed.\n  *\n  * @param {String} key\n  * @param {*} val\n  */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n  * Add an owner vm, so that when $set/$delete mutations\n  * happen we can notify owner vms to proxy the keys and\n  * digest the watchers. This is only called when the object\n  * is observed as an instance's root $data.\n  *\n  * @param {Vue} vm\n  */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm)\n}\n\n/**\n  * Remove an owner vm. This is called when the object is\n  * swapped out as an instance's $data object.\n  *\n  * @param {Vue} vm\n  */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm)\n}\n\n// helpers\n\n/**\n  * Augment an target Object or Array by intercepting\n  * the prototype chain using __proto__\n  *\n  * @param {Object|Array} target\n  * @param {Object} proto\n  */\n\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\n\n/**\n  * Augment an target Object or Array by defining\n  * hidden properties.\n  *\n  * @param {Object|Array} target\n  * @param {Object} proto\n  */\n\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i]\n    def(target, key, src[key])\n  }\n}\n\n/**\n  * Attempt to create an observer instance for a value,\n  * returns the new observer if successfully observed,\n  * or the existing observer if the value already has one.\n  *\n  * @param {*} value\n  * @param {Vue} [vm]\n  * @return {Observer|undefined}\n  * @static\n  */\n\nexport function observe (value, vm) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    hasOwn(value, '__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (ob && vm) {\n    ob.addVm(vm)\n  }\n  return ob\n}\n\n/**\n  * Set a property on an object. Adds the new property and\n  * triggers change notification if the property doesn't\n  * already exist.\n  *\n  * @param {Object} obj\n  * @param {String} key\n  * @param {*} val\n  * @public\n  */\n\nexport function set (obj, key, val) {\n  if (hasOwn(obj, key)) {\n    obj[key] = val\n    return\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val)\n    return\n  }\n  var ob = obj.__ob__\n  if (!ob) {\n    obj[key] = val\n    return\n  }\n  ob.convert(key, val)\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._proxy(key)\n      vm._digest()\n    }\n  }\n  return val\n}\n\n/**\n  * Delete a property and trigger change if necessary.\n  *\n  * @param {Object} obj\n  * @param {String} key\n  */\n\nexport function del (obj, key) {\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key]\n  var ob = obj.__ob__\n  if (!ob) {\n    return\n  }\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._unproxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n* Get the value from an expression on this vm.\n*\n* @param {String} exp\n* @param {Boolean} [asStatement]\n* @return {*}\n*/\n\nVue.prototype.$get = function (exp, asStatement) {\nvar res = parseExpression(exp)\nif (res) {\n  if (asStatement && !isSimplePath(exp)) {\n    var self = this\n    return function statementHandler () {\n      self.$arguments = toArray(arguments)\n      var result = res.get.call(self, self)\n      self.$arguments = null\n      return result\n    }\n  } else {\n    try {\n      return res.get.call(this, this)\n    } catch (e) {}\n  }\n}\n}\n\n/**\n* Set the value from an expression on this vm.\n* The expression must be a valid left-hand\n* expression in an assignment.\n*\n* @param {String} exp\n* @param {*} val\n*/\n\nVue.prototype.$set = function (exp, val) {\n    var res = parseExpression(exp, true)\n    if (res && res.set) {\n      res.set.call(this, this, val)\n    }\n}\n\n/**\n* Delete a property on the VM\n*\n* @param {String} key\n*/\n\nVue.prototype.$delete = function (key) {\n    del(this._data, key)\n}\n")])])])}],s=t(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);n.default=a.exports},44:function(e,n,t){e.exports=t.p+"assets/img/vue_watcher.96244100.png"}}]);