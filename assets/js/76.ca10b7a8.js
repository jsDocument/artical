(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{75:function(t,e,a){"use strict";a.r(e);var n=a(0),i=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"数据存储结构"}},[t._v("数据存储结构")]),a("blockquote",[a("p",[t._v("数据结构的操作实现，一般用template来实现，则不需要在写通用实现时，指定数据类型。")])]),a("h2",{attrs:{id:"线性表：逻辑上相邻的元素在物理结构上也是相邻的"}},[t._v("线性表：逻辑上相邻的元素在物理结构上也是相邻的")]),a("ul",[a("li",[t._v("插入与删除运算需要进行大量移动")]),a("li",[t._v("基本运算：置空 InitList(L), 求长度 ListLength(L), 获取第i个元素 GetNode(L, i), 按值查找 LocateNode(L, x), 插入 InsertList(L, i, x), 删除 DeleteList(L, i)")]),a("li",[t._v("线性表的结构SeqList：")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("typedef sturct {\n  DataTYpe data[ListSize];\n  int Length;\n}SeqList;\n")])]),a("h2",{attrs:{id:"线性表的链式存储"}},[t._v("线性表的链式存储")]),a("ul",[a("li",[t._v("单链表\n"),a("ol",[a("li",[t._v("创建：头插入即将新节点更新到链表的前面，head指针指向NULL, p指向新那的数据结点，p->next指向head，再更新head向后移动 head = p")]),a("li",[t._v("创建：尾插入，head指向第一个节点，更新rear->next指向新的节点p，再将rear向后移动 rear = p，rear指向最后一个节点")]),a("li",[t._v("查找：按序号查找与按值查找")]),a("li",[t._v("插入：")]),a("li",[t._v("删除")])])])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("typedef struct node{\n  DataType data;\n  struct node *next;\n}ListNode;\n")])]),a("ul",[a("li",[a("p",[t._v("循环链表: 最一个节点的next指向head，而非NULL")])]),a("li",[a("p",[t._v("双向链表")])])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("typedef struct dlnode{\n  DataType data;\n  struct dlnode *next, *prev;\n}DListNode;\n")])])])}],!1,null,null,null);e.default=i.exports}}]);