(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{253:function(_,v,l){"use strict";l.r(v);var i=l(0),T=Object(i.a)({},(function(){var _=this.$createElement;this._self._c;return this._m(0)}),[function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("div",{staticClass:"content"},[l("h3",{attrs:{id:"http2-的特点及与其他版本的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#http2-的特点及与其他版本的区别"}},[_._v("#")]),_._v(" http2 的特点及与其他版本的区别")]),_._v(" "),l("ul",[l("li",[_._v("二进制分帧")]),_._v(" "),l("li",[_._v("请求多路复用")]),_._v(" "),l("li",[_._v("头部压缩:  HPack使用哈夫曼编码和索引表实现，需要客户端和服务器都维护一个"),l("code",[_._v("表头字段的索引表")])]),_._v(" "),l("li",[_._v("服务器推送：有服务器根据解析 index.html 同事推送资源信息")]),_._v(" "),l("li",[_._v("赋予请求优先级")]),_._v(" "),l("li",[_._v("Curl 不支持 HTTP2")]),_._v(" "),l("li",[_._v("头阻塞：出现在 TCP 层？ HTTP/2 多路复用的并行特性对于 TCP 的丢包恢复机制是不可见的，一个丢失或顺序不对的数据包会导致所有活动的事务停顿，无论其是否受到丢包的直接影响。因为 HTTP2 开了太多并行的 TCP 连接")]),_._v(" "),l("li",[_._v("距离远？丢包可能性更大？")]),_._v(" "),l("li",[_._v("使用HTTP2的特点：\n"),l("ul",[l("li",[l("code",[_._v("解析速度快")]),_._v("：因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段；服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止")]),_._v(" "),l("li",[l("code",[_._v("多路复用")]),_._v("：多个请求可以共用一个 TCP 连接，先响应就先处理谁，这样就充分的压榨了TCP这个全双工管道的性能，当然多路复用是建立在加载的资源在同一域名下。")]),_._v(" "),l("li",[l("code",[_._v("HTTP1.1的Pipelining技术")]),_._v("：HTTP1.1有一个可选的Pipelining技术，即当一个HTTP连接在等待接收响应时可以通过这个连接发送其他请求，但处理响应是按照顺序的，也就是后发的请求有可能"),l("code",[_._v("被先发的阻塞住")]),_._v("，也正因此很多浏览器默认是不开启Pipelining")]),_._v(" "),l("li",[l("code",[_._v("首部压缩")]),_._v("：HTTP/2对消息头采用 HPACK 进行压缩传输")]),_._v(" "),l("li",[l("code",[_._v("服务器推送")]),_._v("：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。")])])])]),_._v(" "),l("p",[_._v("为什么 HTTP1.1 没有办法实现多路复用？")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("HTTP1.1为什么没有多路复用：HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。")])]),_._v(" "),l("li",[l("p",[_._v("HTTP的缺点")]),_._v(" "),l("ol",[l("li",[_._v("通信使用明文，可能会被窃听")]),_._v(" "),l("li",[_._v("不验证通信方的身份，可能遭遇伪装----查证书")]),_._v(" "),l("li",[_._v("无法证明报文的完整性，可能被篡改----数字签名校验")]),_._v(" "),l("li",[_._v("可通过SSL或TLS的组合使用，加密HTTP的通信内容，即HTTPS")]),_._v(" "),l("li",[_._v("HTTP是无状态协议：通过 Cookie 标识")])])]),_._v(" "),l("li",[l("p",[_._v("HTTP3 标准跟踪 RFC---QUIC通用的传输协议：包含流的复用和对每个流的流量控制，这两者与 HTTP/2 中实现的类似。通过在整个连接中提供流级别的可靠性和拥塞控制，比起 TCP 映射，QUIC 更能提高 HTTP 的性能")])]),_._v(" "),l("li",[l("p",[_._v("支持 0-RTT QUIC 连接，减少了建立安全 TLS 连接的数据往返次数。")])]),_._v(" "),l("li",[l("p",[_._v("HTTPS 主要解决的三个安全问题---握手过程主要是和服务器做通讯，生成"),l("code",[_._v("私有秘钥")]),_._v("，最后通过该秘钥"),l("code",[_._v("对称加密传输数据")]),_._v("。还有"),l("code",[_._v("验证证书")]),_._v("的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。")]),_._v(" "),l("ul",[l("li",[_._v("内容隐私")]),_._v(" "),l("li",[_._v("防篡改")]),_._v(" "),l("li",[_._v("确认对方身份")]),_._v(" "),l("li",[_._v("TLS----SSL 协商")])])]),_._v(" "),l("li",[l("p",[_._v("TCP 传输层")]),_._v(" "),l("ol",[l("li",[_._v("对数据进行"),l("code",[_._v("分割")]),_._v("，打上"),l("code",[_._v("标记序号及端口号")]),_._v("，发送给网络层；")]),_._v(" "),l("li",[_._v("(IP)网络层"),l("code",[_._v("增加MAC地址")]),_._v("后转发给链路层")]),_._v(" "),l("li",[_._v("三次握手策略：数据发送出去后，会向对应确认是否已送达，过程中使用的TCP的flag---"),l("code",[_._v("SYN和ACK")]),_._v(" "),l("ul",[l("li",[_._v("发送端发送一个带"),l("code",[_._v("SYN标志")]),_._v("(建立联机)的数据包给对方----建立")]),_._v(" "),l("li",[_._v("接收端收到后回传一个"),l("code",[_._v("SYN/ACK标志")]),_._v("(确认：原SYN+1)的数据包以示传达确认信息-----传达确认")]),_._v(" "),l("li",[_._v("最后发送端再回传一个带"),l("code",[_._v("ACK+1")]),_._v("标志的数据包；以示结束。-----确认收到")])])]),_._v(" "),l("li",[_._v("四次挥手\n"),l("ul",[l("li",[_._v("客户端发送一个"),l("code",[_._v("FIN标记")]),_._v("(结束)的数据包到服务端")]),_._v(" "),l("li",[_._v("服务端收到后再返回一个"),l("code",[_._v("ACK标志")]),_._v("的数据包回来")]),_._v(" "),l("li",[l("code",[_._v("服务器端关闭")]),_._v("与客户端的连接，再发送一个"),l("code",[_._v("FIN给到客户端")])]),_._v(" "),l("li",[_._v("客户端再发回ACK的数据包确认")])])])])]),_._v(" "),l("li",[l("p",[_._v("其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。")])]),_._v(" "),l("li",[l("p",[l("a",{attrs:{href:"TSL.png"}},[_._v("TLS 握手过程")])])]),_._v(" "),l("li",[l("p",[_._v("wireshark 抓包 https/http2")])]),_._v(" "),l("li",[l("p",[_._v("http3，基于 UDP，解决了对头阻塞与 TCP 和 TLS握手时的延迟问题")])])])])}],!1,null,null,null);v.default=T.exports}}]);