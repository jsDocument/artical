(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{311:function(s,t,n){"use strict";n.r(t);var a=n(0),e=Object(a.a)({},(function(){var s=this.$createElement;this._self._c;return this._m(0)}),[function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("div",{staticClass:"content"},[n("p",[s._v("「性能分析」，「性能测试」，「内存管理」，「内存查看」，「使用C++插件」，「子进程」，「多线程」，「Cluster模块」，「进程守护管理」")]),s._v(" "),n("ol",[n("li",[s._v("搭建基础服务 HTTP 服务器")]),s._v(" "),n("li",[s._v("连接 DB，定义接口，创建、增删、改查询 DB")]),s._v(" "),n("li",[s._v("缓存层")]),s._v(" "),n("li",[s._v("接口数据")]),s._v(" "),n("li",[s._v("性能测试、压测\n"),n("ul",[n("li",[s._v("ab 官方文档：ab -c200 -n1600 http://127.0.0.1:3000/index")]),s._v(" "),n("li",[s._v("webbench")]),s._v(" "),n("li",[s._v("autocannon")])])])]),s._v(" "),n("p",[s._v("参数\t解释\n-c concurrency\t设定并发数，默认并发数是 1\n-n requests\t设定压测的请求总数\n-t timelimit\t设定压测的时长，单位是秒\n-p POST-file\t设定 POST 文件路径，注意设定匹配的 -T 参数\n-T content-type\t设定 POST/PUT 的数据格式，默认为 text/plain\n-V\t查看版本信息\n-w\t以Html表格形式输出")]),s._v(" "),n("ol",{attrs:{start:"6"}},[n("li",[n("p",[s._v("Nodejs性能分析工具：profile，在启动的时候加上**--prof**即可 和 chrome devtools")]),s._v(" "),n("ul",[n("li",[s._v("node --prof index.js")]),s._v(" "),n("li",[s._v("目录下会立马生成一个文件isolate-0x104a0a000-25750-v8.log")]),s._v(" "),n("li",[s._v("「NodeJs」自带的命令 node --prof-process isolate-0x104a0a000-25750-v8.log > profile.txt")]),s._v(" "),n("li",[s._v("node --inspect-brk index.js；--inspect, -brk代表启动调试的同时暂停程序运行")]),s._v(" "),n("li",[s._v("这时监听了一个websocket，我们就可以通过这个ws进行调试了，地址栏输入chrome://inspect，点击「inspect」就可以进行调试")])])]),s._v(" "),n("li",[n("p",[s._v("代码性能优化")]),s._v(" "),n("ul",[n("li",[s._v("「NodeJs」的底层是基于「C++」 ，最终识别的数据结构还是「buffer」，所以 Buffer 更快")]),s._v(" "),n("li",[s._v("文件操作，以流的方式会更快")]),s._v(" "),n("li",[s._v("减少不必要的计算：「NodeJs」中计算会占用相当大的一部分cpu，包括一些文件的编解码等等，尽量要避免这些操作。")]),s._v(" "),n("li",[s._v("空间换时间：比如上面这种读取，或者一些计算，我们可以"),n("code",[s._v("缓存")]),s._v("起来，下次读取的时候直接调用。")])])]),s._v(" "),n("li",[n("p",[s._v("内存管理")]),s._v(" "),n("ul",[n("li",[s._v("垃圾回收机制：\n"),n("ul",[n("li",[s._v("「GC垃圾回收机制」，垃圾回收机制分为，"),n("code",[s._v("新生代")]),s._v("和"),n("code",[s._v("老生代")]),s._v("两部分，所有新创建的变量都会先进入新生代部分，当新生代内存区域快要"),n("code",[s._v("分配满")]),s._v("的时候，就会进行一次垃圾回收，把无用的变量清除出去给新的变量使用，同时，如果一个"),n("code",[s._v("变量在多次垃圾回收之后依然存在")]),s._v("，那么则认为其是一个"),n("code",[s._v("常用且不会轻易移除")]),s._v("的变量，就会将其放入"),n("code",[s._v("老生代")]),s._v("区域，这样一个循环，同时，"),n("code",[s._v("老生代区域容量更大")]),s._v("，垃圾回收"),n("code",[s._v("相对更慢")]),s._v("一些。")]),s._v(" "),n("li",[s._v("新生代：容量小、垃圾回收更快")]),s._v(" "),n("li",[s._v("老生代：容量大，垃圾回收更慢")]),s._v(" "),n("li",[s._v("所以减少内存的使用也是提高服务性能的手段之一，如果有内存泄漏，会导致服务器性能大大降低。")])])]),s._v(" "),n("li",[s._v("内存泄漏问题处理与修复：「Memory面板」可以检测，点击面板之后点击右上角远点会产生一个快照，显示当前使用了多少内存空间")]),s._v(" "),n("li",[s._v("控制内存使用:\n"),n("ul",[n("li",[s._v("「NodeJs」的「Buffer」的内存分配策略：一种是「小于8kb」的文件，一种是「大于8kb」的文件，小于8kb的文件NodeJs认为频繁的去创建没有必要，所以每次都会先创建一个8kb的空间，然后得到空间之后的去计算「buffer」的占用空间，如果小于8kb就在8kb中给它切一部分使用，依次内推，如果遇到一个小于8kb的「buffer」使余下的空间不够使用的时候就会去开辟新的一份8kb空间，在这期间，如何有任何变量被销毁，则这个空间就会被释放，让后面的使用，这就是「NodeJs」中「Buffer」的空间分配机制，这种算法类似于一种「池」的概览。如果在我们的编码中也会遇到内存紧张的问题，那么我们也可以采取这种策略。")])])])])]),s._v(" "),n("li",[n("p",[s._v("Node多进程使用优化")]),s._v(" "),n("ul",[n("li",[s._v("进程：拥有系统挂载运行程序的单元 拥有一些独立的资源，比如内存空间")]),s._v(" "),n("li",[s._v("线程：进行运算调度的单元 进程内的线程共享进程内的资源 一个进程是可以拥有多个线程的")]),s._v(" "),n("li",[s._v("「NodeJs」中一般启动一个服务会有一个主线程和四个子线程，在「NodeJs」中，主线程运行「v8」与「javascript」，主线程负责主要流程和下发各种工作，通过「时间循环机制」 、「LibUv」再由四个子线程去进行工作。")]),s._v(" "),n("li",[s._v("因为「js」是一门单线程的语言，它正常情况下只能使用到一个「cpu」，不过其「子线程」在 底层也使用到了"),n("code",[s._v("其他「cpu」")]),s._v("，但是依然没有完全解放多核的能力，当计算任务过于繁重的时候，我们就可以也在其他的「cpu」上跑一个「javascript」的运行环境，那么我么先来看看如何用子进程来调用吧")])])]),s._v(" "),n("li",[n("p",[s._v("进程的使用 child_process：master，child")])])]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* master.js */")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 自带的子进程模块 */")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" cp "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'child_process'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* fork一个地址就是启动了一个子进程，每「fork」一次便可以开启一个子进程*/")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" child_process "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" cp"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("fork")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("__dirname "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'/child.js'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 通过send方法给子进程发送消息 */")]),s._v("\nchild_process"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("send")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'主进程发这个消息给子进程'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 通过 on message响应接收到子进程的消息 */")]),s._v("\nchild_process"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("on")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'message'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("str")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'主进程：接收到来自自进程的消息'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" str"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* chlid.js */")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 通过on message 响应父进程传递的消息 */")]),s._v("\nprocess"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("on")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'message'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("str")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'子进程， 收到消息'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" str"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* process是全局变量 通过send发送给父进程 */")]),s._v("\n  process"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("send")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'子进程发给主进程的消息'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("ol",{attrs:{start:"11"}},[n("li",[s._v("Cluster模块\n"),n("ul",[n("li",[s._v("「NodeJs」的部署，目前我们在用的是「Pm2」，其实现原理就是基于这种模块，如果我们可以在不同的核分别去跑一个「http服务」那么是不是类似于我们后端的集群，部署多套服务呢，当客户端发送一个「Http请求」的时候进入到我们的「master node」，当我们收到请求的时候，我们把其请求发送给子进程，让子进程自己处理完之后返回给我，由主进程将其发送回去，那么这样我们是不是就可以利用服务器的多核呢？答案是肯定的，同时这些都不需要我们做过多的东西，这个模块就帮我们实现了，然后我们来实现一个这样的服务，我们创建两个文件app.js,cluster.js，第一个文件呢就是我们日常的启动文件，我们来简单的，使用我们的最开始的那个服务即可：")]),s._v(" "),n("li",[s._v("就这样简单的代码就可以让我们的请求分发到不同的子进程里面去，这一点类似于负载均衡，非常简单，同时我们在启用多线程和没启动的前后分别压测，可以发现启用后的「qps」是前者的「2.5倍」拥有很大的一个提升了，也可以知道进程直接的通信是有损耗的，不然应该就是「三倍」了，那么我们要开启多少个子进程比较合适呢。我们可以使用内置模块「OS」，来获取到当前计算机的「cpu核数」的，我们加一点简单改造")])])]),s._v(" "),n("li",[s._v("NodeJs进程守护与管理")])])])}],!1,null,null,null);t.default=e.exports}}]);