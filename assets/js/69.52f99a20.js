(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{243:function(e,i,r){"use strict";r.r(i);var t=r(0),s=Object(t.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,i=e.$createElement,r=e._self._c||i;return r("div",{staticClass:"content"},[r("h3",{attrs:{id:"axios相关知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#axios相关知识"}},[e._v("#")]),e._v(" axios相关知识")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("默认适配器实现支持：")]),e._v(" "),r("ul",[r("li",[e._v("浏览器创建 XMLHttpRequest")]),e._v(" "),r("li",[e._v("node http 请求")])])]),e._v(" "),r("li",[r("p",[e._v("支持的功能：")]),e._v(" "),r("ul",[r("li",[e._v("Promise API, 拦截请求和响应、转换请求和响应数据、取消请求")]),e._v(" "),r("li",[e._v("自动转换 json 数据、客户端支持防止 CSRF/XSRF攻击")]),e._v(" "),r("li",[e._v("自动根据 data 数据类型设置 headers，如 Content-Type")]),e._v(" "),r("li",[e._v("支持自定义转换请求和响应数据")])])]),e._v(" "),r("li",[r("p",[e._v("支持使用方式：")]),e._v(" "),r("ul",[r("li",[e._v("axios.request(config) 最终http请求都是执行这个方法")]),e._v(" "),r("li",[e._v("axios(config) 和axios.request()等价")]),e._v(" "),r("li",[e._v("axios(url[, config]) axios(config)快捷方式")]),e._v(" "),r("li",[e._v("axios.[METHODS](url, config) axios(config)快捷方式")]),e._v(" "),r("li",[e._v("自定义实例\n"),r("ul",[r("li",[e._v("axios.create(config) 自定义配置，创建实例instance。调用方式和axios方法一致")])])])])]),e._v(" "),r("li",[r("p",[e._v("取消请求：Axios.CancelToken(cancel=>{ cancel(url) })")])]),e._v(" "),r("li",[r("p",[e._v("Axios.AbortController()")])]),e._v(" "),r("li",[r("p",[e._v("拦截器---对请求和响应的自定义处理【其实就相当于预处理函数，插入 chain 数组，送入 promise 按顺序执行】，")]),e._v(" "),r("ul",[r("li",[e._v("promise = Promise.resolve(config)")]),e._v(" "),r("li",[e._v("如：[[interceptor.fulfilled, interceptor.rejected], [dispatchRequest, undefined], [interceptor.fulfilled, interceptor.rejected]]")]),e._v(" "),r("li",[e._v("promise = promise.then(chain.shift(), chain.shift()) return promise")]),e._v(" "),r("li",[e._v("拦截请求 axiosInstance.interceptors.request.use()")]),e._v(" "),r("li",[e._v("拦截请求 axiosInstance.interceptors.response.use()")])])]),e._v(" "),r("li",[r("p",[e._v("适配器adaptor 根据环境调用不同的 adaptor 发送请求")])]),e._v(" "),r("li",[r("p",[e._v("transformRequest请求转换：isFormData, isArrayBuffer, isBuffer, isStream, isFile, isBlob")]),e._v(" "),r("ul",[r("li",[e._v("isArrayBufferView---data.buffer")]),e._v(" "),r("li",[e._v("isURLSearchParams---'application/x-www-form-urlencoded;charset=utf-8', data.toString()")]),e._v(" "),r("li",[e._v("isObject---'application/json;charset=utf-8', JSON.stringify")])])]),e._v(" "),r("li",[r("p",[e._v("transformResponse响应数据转换：parse")])]),e._v(" "),r("li",[r("p",[e._v("xsrfCookieName: 'XSRF-TOKEN',")])]),e._v(" "),r("li",[r("p",[e._v("xsrfHeaderName: 'X-XSRF-TOKEN',")])])]),e._v(" "),r("h4",{attrs:{id:"请求并发控制，错误重试-config-retrycount-config-retry-，取消请求、超时取消请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#请求并发控制，错误重试-config-retrycount-config-retry-，取消请求、超时取消请求"}},[e._v("#")]),e._v(" 请求并发控制，错误重试(config.__retryCount, config.retry)，取消请求、超时取消请求")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("使用拦截器实现：")]),e._v(" "),r("ul",[r("li",[e._v("request---fulfilled\n"),r("ul",[r("li",[e._v("addPendingRequest(config)--config. cancelRequest --\x3e 定义 config.cancelToken = 则根据 config 生成 requestKey，在 pendingRequest 中存在，取消; 否则直接取消(重复请求)")]),e._v(" "),r("li",[e._v("cacheReqInterceptor(config, axios)--缓存可用就取消请求")])])]),e._v(" "),r("li",[e._v("request---rejected Promise.reject")]),e._v(" "),r("li",[e._v("response---fulfilled\n"),r("ul",[r("li",[e._v("removePendingRequest(response)---根据 config 生成 requestKey，判断 pendingRequest 中有该请求，获取 cancelToken并执行取消，再删除 requestKey(重复请求)")]),e._v(" "),r("li",[e._v("cacheResInterceptor(response)--请求到数据，更新 localStorage")])])]),e._v(" "),r("li",[e._v("response---rejected\n"),r("ul",[r("li",[e._v("removePendingRequest")]),e._v(" "),r("li",[e._v("againRequest----延时处理把请求加入微任务")]),e._v(" "),r("li",[e._v("Axios.isCancel(error) 缓存处理方式")])])])])]),e._v(" "),r("li",[r("p",[e._v("取消重复请求： 完全相同的接口在上一个pending状态时，自动取消下一个请求")])]),e._v(" "),r("li",[r("p",[e._v("请求失败自动重试： 接口请求后台异常时候，自动重新发起多次请求，直到达到所设次数")])]),e._v(" "),r("li",[r("p",[e._v("请求接口数据缓存：接口在设定时间内不会向后台获取数据，而是直接拿本地缓存---localStorage")])]),e._v(" "),r("li",[r("p",[e._v("超时取消：cancelToken")])])])])}],!1,null,null,null);i.default=s.exports}}]);