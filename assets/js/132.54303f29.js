(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{305:function(e,l,o){"use strict";o.r(l);var s=o(0),t=Object(s.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,l=e.$createElement,o=e._self._c||l;return o("div",{staticClass:"content"},[o("ul",[o("li",[o("p",[e._v("Node 定位 CUP 暴涨与内存泄漏")]),e._v(" "),o("ul",[o("li",[e._v("V8 自动的内存分配和释放，有一些引用不释放，通过启动参数解决解决---devTool+heapdump 或 mewatch")]),e._v(" "),o("li",[e._v("当垃圾回收触发，未使用内存被释放后，内存增长还在持续，我们才能确定是发生了内存泄漏。")]),e._v(" "),o("li",[e._v("node 启动参数 --expose-gc 调用 global.gc()手动触发垃圾回收操作，process.memoryUsage().heapUsed 获取运行时占用的内存")]),e._v(" "),o("li",[e._v("内存快照：比对堆栈信息---comparision, summary")]),e._v(" "),o("li",[e._v("或者：devTool--\x3eprofiles--\x3eload 加载之前生产快照；")])])]),e._v(" "),o("li",[o("p",[e._v("node 内存占用是多少量级？如何知道某个进程消耗多少内存？")])])])])}],!1,null,null,null);l.default=t.exports}}]);