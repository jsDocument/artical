(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{314:function(e,t,l){"use strict";l.r(t);var o=l(0),s=Object(o.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("div",{staticClass:"content"},[l("h2",{attrs:{id:"当event-loop进入-poll-阶段，并且-没有设定的timers（there-are-no-timers-scheduled），会发生下面两件事之一："}},[l("a",{staticClass:"header-anchor",attrs:{href:"#当event-loop进入-poll-阶段，并且-没有设定的timers（there-are-no-timers-scheduled），会发生下面两件事之一："}},[e._v("#")]),e._v(" 当event loop进入 poll 阶段，并且 没有设定的timers（there are no timers scheduled），会发生下面两件事之一：")]),e._v(" "),l("p",[e._v("如果 poll 队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限；\n如果 poll 队列为空，则发生以下两件事之一：\n如果代码已经被setImmediate()设定了回调, event loop将结束 poll 阶段进入 check 阶段来执行 check 队列（里的回调）。\n如果代码没有被setImmediate()设定回调，event loop将阻塞在该阶段等待回调被加入 poll 队列，并立即执行。")]),e._v(" "),l("p",[e._v("但是，当event loop进入 poll 阶段，并且 有设定的timers，一旦 poll 队列为空（poll 阶段空闲状态）：")]),e._v(" "),l("ol",[l("li",[e._v("event loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 "),l("strong",[e._v("timers")]),e._v(" 阶段，并执行 "),l("strong",[e._v("timer")]),e._v(" 队列。")])]),e._v(" "),l("p",[e._v("check")]),e._v(" "),l("p",[e._v("这个阶段允许在 poll 阶段结束后立即执行回调。如果 poll 阶段空闲，并且有被setImmediate()设定的回调，event loop会转到 check 阶段而不是继续等待。")]),e._v(" "),l("p",[e._v("setImmediate()实际上是一个特殊的timer，跑在event loop中一个独立的阶段。它使用libuv的API\n来设定在 poll 阶段结束后立即执行回调。")]),e._v(" "),l("p",[e._v("通常上来讲，随着代码执行，event loop终将进入 poll 阶段，在这个阶段等待 incoming connection, request 等等。但是，只要有被setImmediate()设定了回调，一旦 poll 阶段空闲，那么程序将结束 poll 阶段并进入 check 阶段，而不是继续等待 poll 事件们 （poll events）。")]),e._v(" "),l("p",[e._v("close callbacks")]),e._v(" "),l("p",[e._v("如果一个 socket 或 handle 被突然关掉（比如 socket.destroy()），close事件将在这个阶段被触发，否则将通过process.nextTick()触发。")])])}],!1,null,null,null);t.default=s.exports}}]);