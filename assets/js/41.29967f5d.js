(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{217:function(v,_,l){"use strict";l.r(_);var t=l(0),e=Object(t.a)({},(function(){var v=this.$createElement;this._self._c;return this._m(0)}),[function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("div",{staticClass:"content"},[l("ol",[l("li",[v._v("mouseover与mouseenter事件的区别\nmouseover事件, 鼠标每次进入都会触发该事件, 事件进行冒泡; 而mouseenter只会触发一次, 事件不进行冒泡。")]),v._v(" "),l("li",[v._v("移动端click事件行为与PC端有什么不同, 如何屏蔽掉这个不同\n移动端click会有300ms的延迟, 因为手机浏览器需要处理复杂的手势动作, 浏览器厂商为了识别其他手势动作, 所以加了300ms的延迟; 引入fastclick来检测到touchEnd事件时, 通过DOM自定义事件立即触发一个模拟click事件, 并把浏览器300ms后的真正的click事件阻止掉。")]),v._v(" "),l("li",[v._v("Event中, currentTarget与target之间的区别\n遍历DOM时currentTarget识别事件的当前目标, event.target识别事件发生的元素")]),v._v(" "),l("li",[v._v("事件捕获、事件冒泡、与阻止事件冒泡与默认事件")])]),v._v(" "),l("ul",[l("li",[v._v("事件分为两个阶段: 事件捕获即从根节点查找当前事件发生的元素的过程; 事件冒泡即从事件发生的元素到根节点的过程。")]),v._v(" "),l("li",[v._v("e.stopPropagation()")]),v._v(" "),l("li",[v._v("e.preventDefault() 阻止默认事件")])]),v._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[v._v("移动端的点击穿透, 原因与解决方法")])]),v._v(" "),l("ul",[l("li",[v._v("由于click事件延迟300ms触发, 那么如果300ms内页面显示变化, 会出现实际点击元素触发了touch事件, 300ms后又触发了click事件的情况")])]),v._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[v._v("事件委托\n指利用事件冒泡, 通过指定一个事件处理来管理一种类型的所有事件, 即当些事件处理程序被触发时, 通过当前事件中的target来确定究竟是哪个元素触发了事件, 从面达到一次注册, 多个事件触发事件的目的。")]),v._v(" "),l("li",[v._v("事件循环")])]),v._v(" "),l("ul",[l("li",[v._v("javascript是单线程, 『主线程』负责执行所有的同步任务, 一旦所有的同步任务执行完成了, 则立即从任务队列中读取最优先的任务放到『主线程』中执行, 如些循环往复。")])]),v._v(" "),l("ol",{attrs:{start:"8"}},[l("li",[v._v("css3哪些属性影响Js中的事件: pointer-events, touch-action并讲解一下")])]),v._v(" "),l("ul",[l("li",[v._v("pointer-events: 某个特定的图形元素可以成为鼠标事件的target, 当该属性值设定为none时表示鼠标事件『穿透』该元素并且指定该元素『下面』的任何东西, 其他值时鼠标事件可以指向后代元素, 这样鼠标在捕获或冒泡阶段触发父元素的事件侦听器。")]),v._v(" "),l("li",[v._v("touch-action: 指定某个给定的区域是否允许用户操作, 以及如何响应用户的操作。")])]),v._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[l("p",[v._v("undefined 与 null的区别")]),v._v(" "),l("ul",[l("li",[v._v("两个数据类型都只有一个值")]),v._v(" "),l("li",[v._v("都没有方法")]),v._v(" "),l("li",[v._v("转换为布尔值都为false")]),v._v(" "),l("li",[v._v("null是关键字, 而undefined不是")]),v._v(" "),l("li",[v._v("null是一个空对象, 进行数字类型转换时为0, typeof运算返回object")]),v._v(" "),l("li",[v._v("undefined 是一个window属性, 进行数字类型转换时为NaN, typeof运算返回undefined")])])]),v._v(" "),l("li",[l("p",[v._v("判断一个题目为NaN？")]),v._v(" "),l("ul",[l("li",[v._v("先判断是否为number类型 再isNaN()")]),v._v(" "),l("li",[v._v("利用唯一一个不等于他本身的值的特性, n !== n")]),v._v(" "),l("li",[v._v("Object.is()")])])]),v._v(" "),l("li",[l("p",[v._v("判断两个浮点数相等")]),v._v(" "),l("ul",[l("li",[v._v("计算误差范围值, Math.pow(2, -52), Es6中的Number.EPSILON")]),v._v(" "),l("li",[v._v("两个值相减, 误差小于这个范围")])])])]),v._v(" "),l("blockquote",[l("p",[v._v("Number.MAX_VALUE, Number.MIN_VALUE 最大浮点数与最小浮点数")])]),v._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[l("p",[v._v("检查一个数值是否为整数")]),v._v(" "),l("ul",[l("li",[v._v("Number.isInterger()")]),v._v(" "),l("li",[v._v("判断类型为number且对1求余等于0")])])]),v._v(" "),l("li",[l("p",[v._v("当一个变量显式类型转换时, 遵循的规则是什么")])]),v._v(" "),l("li",[l("p",[v._v("Number([])和Number([1,2,3])的值分别是？说明其原理")])]),v._v(" "),l("li",[l("p",[v._v("parseInt()方法遵循的运算规则")])]),v._v(" "),l("li",[l("p",[v._v("对一个值进行取整的方法有多少种, 分别是？")]),v._v(" "),l("ul",[l("li",[v._v("parseInt")]),v._v(" "),l("li",[v._v("n|0, ~~n, n>>0 只能对32位的数字进行转换, 能处理的为2^(+/-)31的范围")]),v._v(" "),l("li",[v._v("ceil, floor, round")])])]),v._v(" "),l("li",[l("p",[v._v("date接受几种形式的参数")])]),v._v(" "),l("li",[l("p",[v._v("优雅的给出今天星期几")]),v._v(" "),l("ul",[l("li",[v._v("'日一二三四五六'.charAt(new Date().getDay())")])])]),v._v(" "),l("li",[l("p",[v._v("将日期输出成指定格式")])]),v._v(" "),l("li",[l("p",[v._v("计算两个时间点的时间差")])]),v._v(" "),l("li",[l("p",[v._v("获取几天后的时间点对应的时间对象")])])])])}],!1,null,null,null);_.default=e.exports}}]);