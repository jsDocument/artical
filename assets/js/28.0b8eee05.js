(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{218:function(n,e,t){"use strict";t.r(e);var s=t(6),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"简单的链表题目"}},[n._v("简单的链表题目")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/linked-list-cycle/",target:"_blank",rel:"noopener noreferrer"}},[n._v("环形链表"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        int i=0;\n        ListNode *fast = head, *slow = head;\n        if(head != NULL && head->next == head){\n             return true;\n        }\n        while(head != NULL && fast != NULL){\n            slow = slow->next;\n            if(fast->next != NULL){\n                fast = fast->next->next;\n            }else{\n                return false;\n            }\n            if(slow==head) return true;\n            if(fast==head) return true;\n            if(slow == fast) return true;\n        }\n        return false;\n    }\n};\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/",target:"_blank",rel:"noopener noreferrer"}},[n._v("相交链表"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA==NULL || headB==NULL) return NULL;\n        int i = 0, j = 0, k = 0;\n        ListNode *a = headA, *b = headB;\n        while(a != NULL || b != NULL){\n            if(a != NULL){\n                a = a->next;\n                ++i;\n            }\n            if(b != NULL){\n                b = b->next;\n                ++j;\n            }\n        }\n        int dis = abs(i - j);\n        ListNode *find = i>j ? headA : headB;\n        ListNode *short_one = i>j ? headB : headA;\n        while(find != short_one && find != NULL && short_one != NULL){\n            find = find->next;\n            if(dis > k){\n                ++k;\n            }else{\n                short_one = short_one->next;\n            }\n        }\n        if(find == short_one){\n            return find;\n        }else{\n            return NULL;\n        }\n    }\n};\n\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-linked-list-elements/",target:"_blank",rel:"noopener noreferrer"}},[n._v("移除链表元素"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode *cur;\n        while(head != NULL && head->val == val){\n            head = head->next;\n        }\n        if(head == NULL) return NULL;\n        cur = head;\n        while(cur->next != NULL){\n            if(val == cur->next->val){\n                cur->next = cur->next->next;\n            }else{\n                cur = cur->next;\n            }\n        }\n        return head;\n\n    }\n};\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/palindrome-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[n._v("回文链表"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\n    ListNode* findMid(ListNode* head){\n        ListNode *p = head, *mid = head;\n        while(p && p->next){\n            mid = mid->next;\n            p = p->next->next;\n        }\n        return mid;\n    }\n    ListNode* reserveList(ListNode* head){\n        ListNode *prev = NULL, *temp = NULL;\n        while(head){\n            // 暂存next结点\n            temp = head->next;\n            // 更新当前结点的next指向\n            head->next = prev;\n            // 更新上一结点\n            prev = head;\n            // 更新当前结点\n            head = temp;\n        }\n        return prev;\n    }\npublic:\n    int isPalindrome(ListNode* head) {\n        if(!head || !head->next) return true;\n        else if(head && head->next && head->val == head->next->val && !head->next->next) return true;\n        else if(head && head->next && !head->next->next) return false;\n        ListNode *mid = findMid(head);\n        cout<<mid->val<<endl;\n        mid = reserveList(mid);\n        ListNode *before = head, *after = mid;\n        while(before && after && before->val == after->val){\n            before = before->next;\n            after = after->next;\n        }\n        return after == NULL;\n    }\n};\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[n._v("删除链表中的节点"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/reverse-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[n._v("反转链表"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("/**\n * @param {ListNode} head\n * @return {ListNode}\n */")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[n._v("reverseList")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[n._v("head")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("let")]),n._v(" prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" head"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("if")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("!")]),n._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("||")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("!")]),n._v("prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" prev\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("let")]),n._v(" next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("let")]),n._v(" cur "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("while")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n        next "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" cur "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("&&")]),n._v(" cur"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("cur"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n            cur"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("==")]),n._v(" head"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n                prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("else")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("break")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n        prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" cur"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n        cur "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n")])])]),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL, *cur = head, *next=NULL;\n        while(cur != NULL){\n            next = cur->next;\n            cur->next = prev;\n            prev = cur;\n            cur = next;\n        }\n        return prev;\n    }\n};\n")])])]),t("p",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/middle-of-the-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[n._v("链表的中间结点"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n  let fast = head;\n  let slow = head;\n  while(fast && fast.next){\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);