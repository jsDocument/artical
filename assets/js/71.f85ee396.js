(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{248:function(_,v,e){"use strict";e.r(v);var l=e(0),i=Object(l.a)({},(function(){var _=this.$createElement;this._self._c;return this._m(0)}),[function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("div",{staticClass:"content"},[e("h3",{attrs:{id:"后端常见缓存问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后端常见缓存问题"}},[_._v("#")]),_._v(" 后端常见缓存问题")]),_._v(" "),e("p",[_._v("业务查询数据时，会先查询缓存，如果缓存中存在该数据则直接返回，如果没有则继续查询数据库，然后返回。并更新缓存。")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("缓存穿透：缓存穿透是指用户请求的数据在"),e("code",[_._v("缓存中不存在")]),_._v("即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有"),e("code",[_._v("恶意攻击")]),_._v("者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。")]),_._v(" "),e("ul",[e("li",[_._v("存储这些空数据的 key 进 Redis 中，对应的值设置为null")]),_._v(" "),e("li",[_._v("使用布隆过滤器 BloomFilter：缓存之前再加一道屏障，将"),e("code",[_._v("数据库中的所有 key")]),_._v(" 都存储在布隆过滤器中，在查询 Redis 前先去布隆过滤器查询 "),e("code",[_._v("key 是否存在")]),_._v("，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。")])])]),_._v(" "),e("li",[e("p",[_._v("缓存击穿：在高并发情况下，大量请求查询同一个key时，恰好到了缓存过期时间点，导致大量请求发现缓存中该 key 不存在，"),e("code",[_._v("直接向数据库发起查询请求")]),_._v("导致数据库压力激增。")]),_._v(" "),e("ul",[e("li",[_._v("第一是否可以考虑热点 key 不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。")]),_._v(" "),e("li",[_._v("在查询数据的请求上使用一个"),e("code",[_._v("互斥锁")]),_._v("，，其他请求查询数据是发现拿不到锁，就进行等待，等待第一个线程查询到数据后，将数据缓存。其他请求再走缓存")]),_._v(" "),e("li",[_._v("缓存预热：系统上线后，提前将相关的缓存数据加载到缓存系统")]),_._v(" "),e("li",[_._v("缓存降级：直接返回默认数据或访问服务的内存数据。")])])]),_._v(" "),e("li",[e("p",[_._v("缓存雪崩：某一时刻发生大规模的缓存失效的情况，如缓存服务宕机，这样就会有大量的请求直接查询数据库，导致数据库压力剧增，甚至引起宕机。")]),_._v(" "),e("ul",[e("li",[_._v("采用缓存集群，如redis的使用 主从+哨兵")]),_._v(" "),e("li",[_._v("熔断机制：限流降级，当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。")])])])])])}],!1,null,null,null);v.default=i.exports}}]);