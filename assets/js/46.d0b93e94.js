(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{225:function(e,o,t){"use strict";t.r(o);var n=t(0),s=Object(n.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"模块简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块简介"}},[e._v("#")]),e._v(" 模块简介")]),e._v(" "),t("ul",[t("li",[e._v("amd---典型代表require.js")]),e._v(" "),t("li",[e._v("cmd---典型代表sea.js")]),e._v(" "),t("li",[e._v("umd----兼容 cjs 与 amd 的模块")]),e._v(" "),t("li",[e._v("cjs--commonjs----nodejs----转换：skypack、 snowpack、vite\n"),t("ul",[t("li",[e._v("值拷贝")]),e._v(" "),t("li",[e._v("运行时加载")]),e._v(" "),t("li",[e._v("所谓 exports 仅仅是 module.exports 的引用而已")])])]),e._v(" "),t("li",[e._v("esm---支持动态导入 m = await import(\"xxx\"); m.default(xxx)，通过设置 type='module'来支持，但只支持 URL 路径\n"),t("ul",[t("li",[e._v("importMap，定义引入库路径对象，后面就可以支持只引入模块名无需写完整的 URL 了")]),e._v(" "),t("li",[e._v("也可以导入 JSON 和 CSS")]),e._v(" "),t("li",[e._v("预编译期间进行 treeShaking")]),e._v(" "),t("li",[e._v("编译时加载")]),e._v(" "),t("li",[e._v("值引用")])])])]),e._v(" "),t("p",[e._v("CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：")]),e._v(" "),t("p",[e._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\nCommonJs 是单个值导出，ES6 Module可以导出多个\nCommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层\nCommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined")])])}],!1,null,null,null);o.default=s.exports}}]);