(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{318:function(t,a,n){"use strict";n.r(a);var s=n(0),e=Object(s.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"react-事件的相关功能实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-事件的相关功能实现"}},[t._v("#")]),t._v(" react 事件的相关功能实现")]),t._v(" "),n("ol",[n("li",[t._v("为什么要自定义事件机制？\n"),n("ol",[n("li",[t._v("抹平不同浏览器的差异，实现更好的跨平台。")]),t._v(" "),n("li",[t._v("与内部的「优先级机制」绑定，方便事件统一管理和事务机制。")]),t._v(" "),n("li",[t._v("避免垃圾回收，React 引入"),n("code",[t._v("事件池")]),t._v("，在事件池中获取或释放事件对象，避免"),n("code",[t._v("频繁地去创建和销毁")]),t._v("。")])])])]),t._v(" "),n("h4",{attrs:{id:"核心模块"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心模块"}},[t._v("#")]),t._v(" 核心模块")]),t._v(" "),n("ol",[n("li",[t._v("SyntheticEvent(合成事件)：对原生浏览器事件的一层封装，拥有和原生浏览器事件相同的 API，如：stopPropagation() 和 preventDefault()")]),t._v(" "),n("li",[t._v("模拟实现的事件传播机制")])]),t._v(" "),n("div",{staticClass:"language-javascript line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SyntheticEvent")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPropagation")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_stopPropagation "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stopPropagation"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPropagation")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br")])]),n("p",[t._v("接收「原生事件对象」，返回一个包装对象。原生事件对象会保存在nativeEvent属性中。同时，实现了stopPropagation方法。")]),t._v(" "),n("p",[t._v("事件传播机制的实现步骤如下：")]),t._v(" "),n("ol",[n("li",[t._v("在根节点绑定事件类型对应的事件回调，所有子孙节点触发该类事件最终都会~委托~给「根节点的事件回调」处理。")]),t._v(" "),n("li",[t._v("「寻找」触发事件的DOM节点，找到其对应的FiberNode（即虚拟DOM节点）")]),t._v(" "),n("li",[t._v("「收集」从当前FiberNode到根FiberNode之间所有注册的「该事件对应回调」")]),t._v(" "),n("li",[t._v("「反向遍历并执行」一遍所有收集的回调（模拟捕获阶段的实现）")]),t._v(" "),n("li",[t._v("「正向遍历并执行」一遍所有收集的回调（模拟冒泡阶段的实现）")])]),t._v(" "),n("p",[t._v("addEvent---dispatchEvent「根节点的事件回调」-----「通过 DOM 节点找到对应的 FiberNode」----collectPaths「收集路径中该事件的所有回调函数」-----triggerEventFlow「捕获阶段的实现」-----triggerEventFlow「冒泡阶段的实现」")]),t._v(" "),n("h4",{attrs:{id:"要点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[t._v("#")]),t._v(" 要点")]),t._v(" "),n("ol",[n("li",[t._v("se = new SyntheticEvent() 包装合成事件")]),t._v(" "),n("li",[t._v("fiberNode.memoizedProps 保存对应事件回调")]),t._v(" "),n("li",[t._v("collectPaths 是遍历 fiber与 fiber.return 链表，根据 fiber.tag 类型更新paths[{type: callback}]")]),t._v(" "),n("li",[t._v("捕获阶段，从后向前遍历 paths，执行并传入合成事件，如果 se._stopPropagation 这中断接下来的变量")]),t._v(" "),n("li",[t._v("!se._stopPropagation")])]),t._v(" "),n("ul",[n("li",[n("p",[t._v("React 合成事件：声明了事件保存的位置，但是事件有没有被真正的注册")]),t._v(" "),n("ul",[n("li",[t._v("优点：抹平了浏览器事件的差异、提供了统一的事件处理机制、通过事件委托提高性能")]),t._v(" "),n("li",[t._v("过程：\n"),n("ul",[n("li",[t._v("对应虚拟节点创建 fiber 节点，当这个fiber节点进入render阶段的complete阶段时，定义的事件 prop 会被识别，对事件进行处理")]),t._v(" "),n("li",[t._v("React事件：原生事件的 map，定义了什么阶段执行")])])])])]),t._v(" "),n("li",[n("p",[t._v("我们写的事件是绑定在dom上么，如果不是绑定在哪里？")]),t._v(" "),n("ul",[n("li",[t._v("绑定到 root 节点上，统一管理")]),t._v(" "),n("li",[t._v("真实的 dom 的事件回调被替换成了 noop")]),t._v(" "),n("li",[t._v("按需绑定到 root，发现了 onClick 事件再去绑定 document click 事件")]),t._v(" "),n("li",[t._v("真正的回调存在了 fiber 节点的属性上，即判断是HostComponent(dom元素)类型的fiber，通过 diffProperties 单独处理--\x3e处理事件监听(冒泡处理？捕获处理？scroll事件，focus 事件 ，blur)")]),t._v(" "),n("li",[t._v("listener = dispatchEvent.bind( null, topLevelType, eventSystemFlags, targetContainer)统一的监听器，事件触发执行的函数\n"),n("ul",[n("li",[t._v("根据事件源找真正的 dom，根据 dom 找对应的 fiber 对象(targetInst?)，然后进入 legacy 模式的事件处理系统")]),t._v(" "),n("li",[t._v("怎么找 fiber 对象？真实 dom 在初始化是用一个随机 key(__reactInternalInstance$') 指向 fiber，而 fiber.stateNode 指向当前 dom")]),t._v(" "),n("li",[t._v("legacy 模式的事件处理系统与批量更新\n"),n("ul",[n("li",[t._v("handerClick里面触发setState，那么就能读取到 isBatchingEventUpdates = true这就是React的合成事件为什么具有批量更新的功能了。")])])])])])])])]),t._v(" "),n("h4",{attrs:{id:"其他问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他问题"}},[t._v("#")]),t._v(" 其他问题")]),t._v(" "),n("ol",[n("li",[t._v("为什么我们的事件不能绑定给组件？")]),t._v(" "),n("li",[t._v("为什么我们的事件手动绑定this(不是箭头函数的情况)")]),t._v(" "),n("li",[t._v("为什么不能用 return false 来阻止事件的默认行为？")]),t._v(" "),n("li",[t._v("react怎么通过dom元素，找到与之对应的 fiber对象的？")]),t._v(" "),n("li",[t._v("onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？")]),t._v(" "),n("li",[t._v("事件池---extractEvents 形成事件对象event 和 事件处理函数队列\n"),n("ol",[n("li",[t._v("handleTopLevel：就是执行事件处理插件(SimpleEventPlugin)中的处理函数extractEvent")]),t._v(" "),n("li",[t._v("namesToPlugins 事件模块插件的映射")]),t._v(" "),n("li",[t._v("plugins")]),t._v(" "),n("li",[t._v("registrationNameModules(记录了React合成的事件-对应的事件插件的关系)\nSimpleEventPlugin,\nEnterLeaveEventPlugin,\nChangeEventPlugin,\nSelectEventPlugin,\nBeforeInputEventPlugin，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系")])])])])])}],!1,null,null,null);a.default=e.exports}}]);