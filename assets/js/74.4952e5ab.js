(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{247:function(e,i,v){"use strict";v.r(i);var _=v(0),l=Object(_.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,i=e.$createElement,v=e._self._c||i;return v("div",{staticClass:"content"},[v("h2",{attrs:{id:"缓存常见问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存常见问题"}},[e._v("#")]),e._v(" 缓存常见问题")]),e._v(" "),v("ul",[v("li",[e._v("缓存穿透：缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。\n"),v("ul",[v("li",[e._v("将无效的key存放进Redis中")]),e._v(" "),v("li",[e._v("使用布隆过滤器：将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。")])])]),e._v(" "),v("li",[e._v("缓存雪崩\n"),v("ul",[v("li",[e._v("均匀过期")]),e._v(" "),v("li",[e._v("分级缓存")]),e._v(" "),v("li",[e._v("热点数据缓存永远不过期：key不设置过期时间，过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建")]),e._v(" "),v("li",[e._v("保证Redis缓存的高可用：防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。")])])])]),e._v(" "),v("p",[e._v("互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降\n使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。\n开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。")]),e._v(" "),v("ul",[v("li",[e._v("缓存击穿：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来；缓存击穿是某个热点的key失效\n"),v("ul",[v("li",[e._v("第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。")]),e._v(" "),v("li",[e._v("互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降")]),e._v(" "),v("li",[e._v("永远不过期")]),e._v(" "),v("li",[e._v("资源保护")])])]),e._v(" "),v("li",[e._v("缓存预热：系统上线后，提前将相关的缓存数据加载到缓存系统")]),e._v(" "),v("li",[e._v("缓存降级：直接返回默认数据或访问服务的内存数据。")])])])}],!1,null,null,null);i.default=l.exports}}]);