(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{327:function(t,n,e){"use strict";e.r(n);var a=e(6),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-事件的相关功能实现"}},[t._v("react 事件的相关功能实现")]),t._v(" "),e("ol",[e("li",[t._v("抹平不同浏览器的差异")]),t._v(" "),e("li",[t._v("与内部的「优先级机制」绑定")]),t._v(" "),e("li",[t._v("考虑所有浏览器事件")])]),t._v(" "),e("h2",{attrs:{id:"核心模块"}},[t._v("核心模块")]),t._v(" "),e("ol",[e("li",[t._v("SyntheticEvent(合成事件)：对原生浏览器事件的一层封装，拥有和原生浏览器事件相同的 API，如：stopPropagation() 和 preventDefault()")]),t._v(" "),e("li",[t._v("模拟实现的事件传播机制")])]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SyntheticEvent")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPropagation")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_stopPropagation "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stopPropagation"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nativeEvent"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPropagation")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("接收「原生事件对象」，返回一个包装对象。原生事件对象会保存在nativeEvent属性中。同时，实现了stopPropagation方法。")]),t._v(" "),e("p",[t._v("事件传播机制的实现步骤如下：")]),t._v(" "),e("ol",[e("li",[t._v("在根节点绑定事件类型对应的事件回调，所有子孙节点触发该类事件最终都会~委托~给「根节点的事件回调」处理。")]),t._v(" "),e("li",[t._v("「寻找」触发事件的DOM节点，找到其对应的FiberNode（即虚拟DOM节点）")]),t._v(" "),e("li",[t._v("「收集」从当前FiberNode到根FiberNode之间所有注册的「该事件对应回调」")]),t._v(" "),e("li",[t._v("「反向遍历并执行」一遍所有收集的回调（模拟捕获阶段的实现）")]),t._v(" "),e("li",[t._v("「正向遍历并执行」一遍所有收集的回调（模拟冒泡阶段的实现）")])]),t._v(" "),e("p",[t._v("addEvent---dispatchEvent「根节点的事件回调」-----「通过 DOM 节点找到对应的 FiberNode」----collectPaths「收集路径中该事件的所有回调函数」-----triggerEventFlow「捕获阶段的实现」-----triggerEventFlow「冒泡阶段的实现」")]),t._v(" "),e("h2",{attrs:{id:"要点"}},[t._v("要点")]),t._v(" "),e("ol",[e("li",[t._v("se = new SyntheticEvent() 包装合成事件")]),t._v(" "),e("li",[t._v("fiberNode.memoizedProps 保存对应事件回调")]),t._v(" "),e("li",[t._v("collectPaths 是遍历 fiber与 fiber.return 链表，根据 fiber.tag 类型更新paths[{type: callback}]")]),t._v(" "),e("li",[t._v("捕获阶段，从后向前遍历 paths，执行并传入合成事件，如果 se._stopPropagation 这中断接下来的变量")]),t._v(" "),e("li",[t._v("!se._stopPropagation")])]),t._v(" "),e("p",[t._v("React 生命周期：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("组件初始化阶段：组件的初始化工作：如定义 this.state 的初始内容")])]),t._v(" "),e("li",[e("p",[t._v("组件的挂载阶段：")]),t._v(" "),e("ul",[e("li",[t._v("ComponentWillMount 在组件挂载到 DOM 前调用，只会被调用一次")]),t._v(" "),e("li",[t._v("render：根据组件的 props 和 state，return 一个React元素")]),t._v(" "),e("li",[t._v("componentDidMount：组件挂载到DOM后调用，且只会被调用一次")])])]),t._v(" "),e("li",[e("p",[t._v("组件的更新阶段：父组件重新 render 引起子组件重新渲染")]),t._v(" "),e("ul",[e("li",[t._v("componentWillReceiveProps")]),t._v(" "),e("li",[t._v("shouldComponentUpdate")]),t._v(" "),e("li",[t._v("componentWillUpdate")]),t._v(" "),e("li",[t._v("componentDidUpdate")])])]),t._v(" "),e("li",[e("p",[t._v("组件的卸载阶段")]),t._v(" "),e("ul",[e("li",[t._v("componentWillUnmount")])])]),t._v(" "),e("li",[e("p",[t._v("React 合成事件：声明了事件保存的位置，但是事件有没有被真正的注册")]),t._v(" "),e("ul",[e("li",[t._v("优点：抹平了浏览器事件的差异、提供了统一的事件处理机制、通过事件委托提高性能")]),t._v(" "),e("li",[t._v("过程：\n"),e("ul",[e("li",[t._v("对应虚拟节点创建 fiber 节点，当这个fiber节点进入render阶段的complete阶段时，定义的事件 prop 会被识别，对事件进行处理")]),t._v(" "),e("li",[t._v("React事件：原生事件的 map，定义了什么阶段执行")])])])])]),t._v(" "),e("li",[e("p",[t._v("我们写的事件是绑定在dom上么，如果不是绑定在哪里？")]),t._v(" "),e("ul",[e("li",[t._v("绑定到 root 节点上，统一管理")]),t._v(" "),e("li",[t._v("真实的 dom 的事件回调被替换成了 noop")]),t._v(" "),e("li",[t._v("按需绑定到 root，发现了 onClick 事件再去绑定 document click 事件")]),t._v(" "),e("li",[t._v("真正的回调存在了 fiber 节点的属性上，即判断是HostComponent(dom元素)类型的fiber，通过 diffProperties 单独处理--\x3e处理事件监听(冒泡处理？捕获处理？scroll事件，focus 事件 ，blur)")]),t._v(" "),e("li",[t._v("listener = dispatchEvent.bind( null, topLevelType, eventSystemFlags, targetContainer)统一的监听器，事件触发执行的函数\n"),e("ul",[e("li",[t._v("根据事件源找真正的 dom，根据 dom 找对应的 fiber 对象(targetInst?)，然后进入 legacy 模式的事件处理系统")]),t._v(" "),e("li",[t._v("怎么找 fiber 对象？真实 dom 在初始化是用一个随机 key(__reactInternalInstance$') 指向 fiber，而 fiber.stateNode 指向当前 dom")]),t._v(" "),e("li",[t._v("legacy 模式的事件处理系统与批量更新\n"),e("ul",[e("li",[t._v("handerClick里面触发setState，那么就能读取到 isBatchingEventUpdates = true这就是React的合成事件为什么具有批量更新的功能了。")])])])])])])])]),t._v(" "),e("p",[t._v("2 为什么我们的事件不能绑定给组件？\n3 为什么我们的事件手动绑定this(不是箭头函数的情况)\n4 为什么不能用 return false 来阻止事件的默认行为？\n5 react怎么通过dom元素，找到与之对应的 fiber对象的？\n6 onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("事件池---extractEvents 形成事件对象event 和 事件处理函数队列")])]),t._v(" "),e("li",[e("p",[t._v("handleTopLevel：就是执行事件处理插件(SimpleEventPlugin)中的处理函数extractEvent")])]),t._v(" "),e("li",[e("p",[t._v("namesToPlugins 事件模块插件的映射")])]),t._v(" "),e("li",[e("p",[t._v("plugins")])]),t._v(" "),e("li",[e("p",[t._v("registrationNameModules(记录了React合成的事件-对应的事件插件的关系)\nSimpleEventPlugin,\nEnterLeaveEventPlugin,\nChangeEventPlugin,\nSelectEventPlugin,\nBeforeInputEventPlugin,\n构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);