(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{271:function(e,n,a){"use strict";a.r(n);var t=a(0),r=Object(t.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"mongodb命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mongodb命令"}},[e._v("#")]),e._v(" mongoDB命令")]),e._v(" "),a("h4",{attrs:{id:"基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[e._v("#")]),e._v(" 基本操作")]),e._v(" "),a("p",[e._v("db  当前数据库\nuse dbName  切换数据库\nshow dbs  所有数据库\nshow collections  所有表\ndb.addUser(name, password)\ndb.system.users.find()\ndb.auth(name, pwd)用户认证\ndb.removeUser(name)\nshow users")]),e._v(" "),a("h3",{attrs:{id:"数据库基础信息查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库基础信息查询"}},[e._v("#")]),e._v(" 数据库基础信息查询")]),e._v(" "),a("p",[e._v("db.getName()\ndb.stats()\ndb.version()\n地址：db.getMongo()\n删除：db.dropDatabase()\n克隆到当前数据库：db.cloneDatabase('127.0.0.1')\n复制：db.copyDatabase('mydb', 'todb', 'ip')\n修复：db.repairDatabase()")]),e._v(" "),a("h4",{attrs:{id:"表的基本查询与操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表的基本查询与操作"}},[e._v("#")]),e._v(" 表的基本查询与操作")]),e._v(" "),a("p",[e._v("db.col.count()\ndb.col.dataSize()\ndb.col.getDB()  所在数据库\ndb.col.stats()\ndb.col.totalSize()\ndb.col.storageSize()\ndb.col.renameCollection('name')\ndb.col.drop()")]),e._v(" "),a("h4",{attrs:{id:"索引查询与操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引查询与操作"}},[e._v("#")]),e._v(" 索引查询与操作")]),e._v(" "),a("p",[e._v("db.col.getIndexes()\ndb.col.createIndex()\ndb.col.dropIndex(indexName)\nensureIndex({field: 1})  -1 升序创建索引")]),e._v(" "),a("p",[e._v("background: 后台\nname:  索引名称\ndropDups：创建唯一索引时删除重复数据\nweights:  权重值\nunique\nsparse----稀疏, 对文档中不存在的字段数据不启用索引，不会查询出不包含对应字段的文档")]),e._v(" "),a("h3",{attrs:{id:"schema与query-关联、查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schema与query-关联、查询"}},[e._v("#")]),e._v(" Schema与query 关联、查询")]),e._v(" "),a("p",[e._v("Schema定义--表2 ref: 'tableName'；此表为子表、外键，被关联的为主表\n查询：表2.find().populate('外键field').exec()\n[^ 子表关联主表查询]\n[^ 当然也可以用主表关联子表查询，那就需要修改两张表的Schema了。 外键应该定义在主表中，而不是上面例子的子表中。]")]),e._v(" "),a("h3",{attrs:{id:"索引基础知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引基础知识"}},[e._v("#")]),e._v(" 索引基础知识")]),e._v(" "),a("p",[e._v("1、唯一索引 db.col.ensureIndex({field: 1/-1},opts), unique\n2、dropDups删除重复\n3、sparse 文档中不存在的字段数据不启用索引，在索引字段中不会查询出「不包含对应字段的文档」\n[^ 索引占据一定的存储空间，故进行插入、更新、删除时需要对索引进行操作，所以对于集合进行读写操作少的，不建义使用]")]),e._v(" "),a("h3",{attrs:{id:"查询条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查询条件"}},[e._v("#")]),e._v(" 查询条件")]),e._v(" "),a("p",[e._v('[^ and：{field: value, field: value}]\n[^ or：{ "$or": {field: value, field: value} }]\n[^ 值的限制：{field: {"$gt": value, "$lt": value}  }]\n[^ 数组：{ field: "$all/in": [value] }  或 {field: [value]}]')]),e._v(" "),a("p",[e._v("{field: {$gt: value}}\n{$set: {field: value}}")]),e._v(" "),a("p",[e._v("表达式规则：\n多重条件or：{'$or', [{A} , {B}]}\n多重条件and：('field', {条件:, 条件: })\n特多：('field', {条件}, $or, [{field, field}])\n({}, {'field': 1/0, ...})   指定(不)返回字段")]),e._v(" "),a("p",[e._v("更新多个id值的数据\n{‘$addToSet’: {field: {'$each': [a, b]}}}")]),e._v(" "),a("p",[e._v("字段的限制:")]),e._v(" "),a("p",[e._v("$set   增加或修改一个字段, upsert, multi；部分更新操作符，更新set之后的数据，而不是覆盖之前的数据\n$unset  删除一个字段\n$inc    递增、递减  已有键的值\n$push  数组\n$addToSet  不重复的为数组里追加一些值配合$each")]),e._v(" "),a("p",[e._v("$pushAll\n$pop\n$popAll\n$elemMatch")]),e._v(" "),a("p",[e._v("值的限制：\n$lt      小于\n$lte      小于等于\n$gt      大于\n$gte      大于等于\n$ne     不等于\n$not  /^T.*/  匹配正则表达式\n$null\n$all [ , ]\n$in   是否在某一集合\n$nin   与$in相反\n$each: [ , ]\n$size   数组长度\n$slice   返回数组子集，支持前、后或者偏移；取哪些记录 10、-10、[1, 10]\n$mod [ 5, 1] 取模5等于1的数据\n$equals\n$exists  true 键值是否存在\n$type: 2\n[Double--\x3e1,String--\x3e2,Object--\x3e3,Array--\x3e4,Binary data--\x3e5,Undefined--\x3e6,Object id--\x3e7,Boolean--\x3e8,Date--\x3e9,Null--\x3e10...]\n"),e._v("\n$sort\n$regex")]),e._v(" "),a("p",[e._v('多字段限制：\n{A, B}\n$or : [A,B]\n$and : [ ,]\n{A, $or: [B, C]}\n$where  {"$where": function(){}}')]),e._v(" "),a("p",[e._v("$rename")]),e._v(" "),a("h3",{attrs:{id:"链式查询方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链式查询方法"}},[e._v("#")]),e._v(" 链式查询方法")]),e._v(" "),a("p",[e._v("where\nequals(value)\nin([list])\nlimit(Number)\nsort('')     -1降序\nselect('')\nexec()\nskip(N)\ncount([true]) 多少条记录\nexplain()  索引查询分析\nhint({fild: 1/-1}) 强制使用一个指定的索引\nmapReduce(fn--map(emit(key, value)), fn--reduce(key, values)=>(return reduceFn), opts)")]),e._v(" "),a("p",[e._v("lean: true 或lean()")]),e._v(" "),a("p",[e._v("query().cursor().on~~~\n或\ncursor = query().cursor()\ncursor.on('data', (doc)=>{})\ncursor.on('close', (doc)=>{})\ncursor.next((err, doc)=>{})")]),e._v(" "),a("h4",{attrs:{id:"数据操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据操作"}},[e._v("#")]),e._v(" 数据操作")]),e._v(" "),a("p",[e._v("db.col.insert()  mongoose不存在则插入\ndb.col.save(opts, safe, validate, fn(err, product, numAffected))不存在插入，存在更新\ndb.col.update(condition, edit, upsert, onlyOne)\nupsert 无匹配则插入，存在则更新，只修改一条数据")]),e._v(" "),a("p",[e._v("onlyOne 只更新一条数据\ndb.col.save(opts, safe, validate, fn(err, product, numAffected))不存在插入，存在更新")]),e._v(" "),a("p",[e._v("db.col.remove(query,{justOne})\ndb.col.update(query, update, opts)")]),e._v(" "),a("p",[e._v("Model.create(data, fn)\nmodel.field = value\nmodel.save()   传入的文档替换已有文档")]),e._v(" "),a("blockquote",[a("p",[e._v("insert() 或 save() 方法都可以向collection里插入数据，两者区别：")])]),e._v(" "),a("ul",[a("li",[e._v("如果不指定 _id 字段，save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。")]),e._v(" "),a("li",[e._v("使用save函数，如果原来的对象不存在，那他们都可以向collection里插入数据，如果已经存在，save会调用update更新里面的记录，而insert则会忽略操作")]),e._v(" "),a("li",[e._v("insert可以一次性插入一个列表，而不用遍历，效率高， save则需要遍历列表，一个个插入。")])]),e._v(" "),a("p",[e._v("modle实例的方法")]),e._v(" "),a("p",[e._v("###mongoose的方法")]),e._v(" "),a("p",[e._v("读取 Model.find(条件, 指定返回的键) / findOne / findById / findByName(条件, 字段, options, fn)")]),e._v(" "),a("p",[e._v("更新  Model.update(query, updates, opts, fn) / findOneAndUpdate / findByIdAndUpdate\nmulti, safe, upsert, runValidators, setDefaultsOnInsert--$setOnInsert, strict, overwrite")]),e._v(" "),a("p",[e._v("删除 Model.remove / findOneAndRemove / findByIdAndRemove")]),e._v(" "),a("p",[e._v("新增：kk = new Model(data)  kk.save();  Model.create(data, fn)")]),e._v(" "),a("p",[e._v("Model.insertMany([],fn)")]),e._v(" "),a("h2",{attrs:{id:"findandmodify-query-update-new-true-选项：query-update-remove-new-sort排序，field，-upsert-与new一起使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#findandmodify-query-update-new-true-选项：query-update-remove-new-sort排序，field，-upsert-与new一起使用"}},[e._v("#")]),e._v(" findAndModify({query: {}, update: {}, new: true})\n选项：query, update, remove, new , sort排序，field， upsert(与new一起使用)")]),e._v(" "),a("h2",{attrs:{id:"mongoose对于结构的声明是有严格顺序要求的子文档是父文档的一具属性，新增父时，子文档会被先加入进去"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mongoose对于结构的声明是有严格顺序要求的子文档是父文档的一具属性，新增父时，子文档会被先加入进去"}},[e._v("#")]),e._v(" mongoose对于结构的声明是有严格顺序要求的\n子文档是父文档的一具属性，新增父时，子文档会被先加入进去")]),e._v(" "),a("p",[e._v("Schema配置\ntype----Schema.Types.Mixed, Schema.Types.ObjectId, [String] [[Number]]")]),e._v(" "),a("p",[e._v("default\nmin\nmax\nlowercase\nuppercase\ntrim\nmatch----RegExp\nenum----创建是否为给定的数值组\nrequired  非空\nselect\nvalidate----fn\nget----fn\nset----fn\nalias  别名")]),e._v(" "),a("p",[e._v("索引\nindex\nunique\nsparse----稀疏, 可以没有")]),e._v(" "),a("p",[e._v("虚拟属性\nschema.virtual(username.full).get(fn return)")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("创建Schema时的配置项\nsafe\nstrict   严格，存入时会自动验证\ncapped   上限设置{size:, max}\nversionKey\nshareKey   分布式才用\nautoIndex")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("ensureIndex({field: 1, field1: 1}, {options}) 创建\ndropindex(‘indexName’) 删除\ndb.col.getIndexes() 读取\ngetLastError查看创建是否成功\n覆盖索引：indexOnly\n唯一：unique\n复合：多个键即可\n稀疏：sparse")]),e._v(" "),a("h2",{attrs:{id:"autoindex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#autoindex"}},[e._v("#")]),e._v(" autoIndex")]),e._v(" "),a("h3",{attrs:{id:"new-schema-数据模型-opts-定义数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-schema-数据模型-opts-定义数据结构"}},[e._v("#")]),e._v(" new Schema(数据模型, opts)  定义数据结构")]),e._v(" "),a("blockquote",[a("p",[e._v("opts：{safe:{j:1,w:2,wtimeout:10000}}")])]),e._v(" "),a("p",[e._v("Schema.add()")]),e._v(" "),a("h3",{attrs:{id:"model的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#model的方法"}},[e._v("#")]),e._v(" Model的方法")]),e._v(" "),a("ul",[a("li",[e._v("find(condition, returnField, cb)")]),e._v(" "),a("li",[e._v("findById")]),e._v(" "),a("li",[e._v("findByIdAndUpdate")]),e._v(" "),a("li",[e._v("remove")]),e._v(" "),a("li",[e._v("update(condition, doc[, opts][, cb])")]),e._v(" "),a("li",[e._v("*insert")])]),e._v(" "),a("blockquote",[a("p",[e._v(".save() 和 query.exec()，返回 Promises/A+; query虽然不是promise但有.then()方法\n支持如此使用mongoose.Promise = global.Promise  ES6 Promise")])]),e._v(" "),a("h3",{attrs:{id:"model实例的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#model实例的方法"}},[e._v("#")]),e._v(" Model实例的方法")]),e._v(" "),a("p",[e._v("保存数据")]),e._v(" "),a("ul",[a("li",[e._v("instance = new Model(data);  instance.save(cb)")]),e._v(" "),a("li",[e._v("Model.create(data, cb)")])]),e._v(" "),a("h3",{attrs:{id:"条件函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件函数"}},[e._v("#")]),e._v(" 条件函数")]),e._v(" "),a("h3",{attrs:{id:"查找条件运用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查找条件运用"}},[e._v("#")]),e._v(" 查找条件运用")]),e._v(" "),a("p",[e._v("数组：\nfield.2   下标")]),e._v(" "),a("p",[e._v("$type   指定类型对应的数值")]),e._v(" "),a("h2",{attrs:{id:"查询没有callback时，返回query-没有执行预编译查询语句，返回的为自己；query-select-query-exec-fn-执行查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查询没有callback时，返回query-没有执行预编译查询语句，返回的为自己；query-select-query-exec-fn-执行查询"}},[e._v("#")]),e._v(" 查询没有callback时，返回query, 没有执行预编译查询语句，返回的为自己；query.select('')   query.exec(fn) 执行查询")]),e._v(" "),a("p",[e._v("删除\nremove  只删除数据\ndrop  返回 true或 false,为true表示删除掉了，会删除整个表，包括表结构")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("query.pretty()  格式化数据")])])}],!1,null,null,null);n.default=r.exports}}]);