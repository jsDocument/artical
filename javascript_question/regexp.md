# 正则

## 正则原理

- 源字符串，都有字符和位置【从0开始逐个匹配】
- 占有字符：子表达式匹配到的是字符内容，而非位置，且在最终结果中；互斥的，即一个字符同一时间只能由一个子表达式匹配
- 零宽度：子表达式匹配到的是仅仅是位置，或者匹配的内容并不保存到最终结果中；非互斥，即可以同时由多个零宽度的子表达式匹配。如：^,
- ?= 顺序环视 匹配当前位置，右边是否有相应限定的字符出现。
- 如 `/^(?=D)[E-F]+$/`
  1. 位置开始位置0；
  2. 零宽度子表达式之间不互斥，即同一个位置可以由多个零宽度子表达式匹配，所以环视从位置0开始尝试匹配，右侧为字符D；才为匹配成功；
  3. 因为上个匹配只进行匹配位置，结果不保存到最终结果，如果上个匹配成功的位置为0，那么下面也是从0位置开始匹配。

## 性能提升

- 减少回溯次数【减少循环查找同一个字符次数】
- 测试与优化工具：regexbuddy
- 使用正确的边界匹配器（^、$、\b、\B等），限定搜索字符串位置
- 使用具体的元字符、字符类（\d、\w、\s等） ，[^]少用”.”字符
- 使用正确的量词（+、\*、?、{n,m}），如果能够限定长度，匹配最佳
- 使用非捕获组、原子组，减少没有必要的字匹配捕获用(?:)
- 进行分组匹配 | + g模式

## 正则特殊表示

- \b 单词边界 \f 换页符  \n换行符  \r 回车符 \t 制表符 \v 垂直制表符  \x20 空白符  \x0A(16)  \011(8)  posix字符类
- \b: 单词与空格之间，一边为\w，一边为非\w
- \B: 左右两边都为\w或非\w

```js
// 好的正则例子:
/^\/\*[^/]\*\*\/$/  // 多行注释
/^\/\/[^\n]\*/  // 单行注释
/^\x20\*\/\/[^0-9\n]\*/
```

### 获取匹配的子捕获: RegExp.$2 != express

### 反向引用：`\1  \2`

```js
// 示例
/tom(?=(and))\1jerry/, /(?=(.+.+))\1+X/
```

### 分组, 零宽度断言, 搜索与反向搜索及特殊表达

- `reg?<name>exp` 匹配exp, 并将捕获文本放到名称为name的组里
- `(?:exp)` 不捕获
- `?=` 正向肯定环视, 即要求表达式中要出现该表达要求的内容, 但不捕获; 如 `/^(?:\/(?=$))?$/i, /^\/dialog(?:\/(?=$))?$/i`,
- `?!` 正向否定环视, 即要求表达式中不要出现该表达要求的内容, 但不捕获;如 `/\((?!\?)/g`
- `?<=` 逆向肯定
- `?!<` 逆向否定
- `(?#comment)` 阅读注释
- `$&` 全文本
- $\` 匹配字符串的左边文本
- $' 匹配字符串的右边文本
- $$  $转移


```js
// 例子
/\d{1,3}(?=(\d{3})+$)/g, '$&,'
```


### 特殊属性的意义

- input, `RegExp.$_` 整个待匹配字符串
- leftContext, RegExp['$\`'] 上次匹配之前的子字符串
- lastMatch, `RegExp['$&']` 最后匹配的字符串
- multiline, `RegExp['$\*']` 是否所有表达式都使用多行模式的布尔值
- lastParen, `RegExp['$+']` 最后匹配的分组

### 汉字范围: `[\u4e00-\u9fff]`
