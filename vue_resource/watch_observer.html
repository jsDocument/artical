<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档 | watch</title>
    <meta name="description" content="偏重前端与node的技术文档">
    
    
    <link rel="preload" href="/assets/css/62.styles.28f5698d.css" as="style"><link rel="preload" href="/assets/js/app.9bd0b60f.js" as="script"><link rel="preload" href="/assets/js/0.07822d9a.js" as="script"><link rel="prefetch" href="/assets/js/30.0c54eea6.js"><link rel="prefetch" href="/assets/js/1.cd75a908.js"><link rel="prefetch" href="/assets/js/2.527be2a2.js"><link rel="prefetch" href="/assets/js/3.56491032.js"><link rel="prefetch" href="/assets/js/4.5805ac16.js"><link rel="prefetch" href="/assets/js/5.44f1ab99.js"><link rel="prefetch" href="/assets/js/6.36d22eb4.js"><link rel="prefetch" href="/assets/js/7.48381e1d.js"><link rel="prefetch" href="/assets/js/8.06d62168.js"><link rel="prefetch" href="/assets/js/9.59895078.js"><link rel="prefetch" href="/assets/js/10.41a97466.js"><link rel="prefetch" href="/assets/js/11.3318df9b.js"><link rel="prefetch" href="/assets/js/12.e0b52ae1.js"><link rel="prefetch" href="/assets/js/13.d607b5c9.js"><link rel="prefetch" href="/assets/js/14.e130e400.js"><link rel="prefetch" href="/assets/js/15.369bb909.js"><link rel="prefetch" href="/assets/js/16.9c0f70b1.js"><link rel="prefetch" href="/assets/js/17.01ec692e.js"><link rel="prefetch" href="/assets/js/18.214e08f9.js"><link rel="prefetch" href="/assets/js/19.0b8c33c8.js"><link rel="prefetch" href="/assets/js/20.288b5fd1.js"><link rel="prefetch" href="/assets/js/21.563b50d5.js"><link rel="prefetch" href="/assets/js/22.05c9ccff.js"><link rel="prefetch" href="/assets/js/23.3462194a.js"><link rel="prefetch" href="/assets/js/24.040595c2.js"><link rel="prefetch" href="/assets/js/25.c7f495fc.js"><link rel="prefetch" href="/assets/js/26.ae8d2116.js"><link rel="prefetch" href="/assets/js/27.3cc403be.js"><link rel="prefetch" href="/assets/js/28.c679e4c7.js"><link rel="prefetch" href="/assets/js/29.34ec5b9e.js"><link rel="prefetch" href="/assets/js/31.6d713360.js"><link rel="prefetch" href="/assets/js/32.a59fc84d.js"><link rel="prefetch" href="/assets/js/33.565ef772.js"><link rel="prefetch" href="/assets/js/34.83c2e76e.js"><link rel="prefetch" href="/assets/js/35.077c8eb1.js"><link rel="prefetch" href="/assets/js/36.8b526962.js"><link rel="prefetch" href="/assets/js/37.2741c29f.js"><link rel="prefetch" href="/assets/js/38.3c1fe803.js"><link rel="prefetch" href="/assets/js/39.ec180b22.js"><link rel="prefetch" href="/assets/js/40.9399ac41.js"><link rel="prefetch" href="/assets/js/41.d672ee9c.js"><link rel="prefetch" href="/assets/js/42.9395bf7a.js"><link rel="prefetch" href="/assets/js/43.723693fc.js"><link rel="prefetch" href="/assets/js/44.95bfdd98.js"><link rel="prefetch" href="/assets/js/45.a0d6209c.js"><link rel="prefetch" href="/assets/js/46.dfe8a8fe.js"><link rel="prefetch" href="/assets/js/47.9bfb1477.js"><link rel="prefetch" href="/assets/js/48.faf89646.js"><link rel="prefetch" href="/assets/js/49.082f17e2.js"><link rel="prefetch" href="/assets/js/50.a3fed70b.js"><link rel="prefetch" href="/assets/js/51.c1ad6ce0.js"><link rel="prefetch" href="/assets/js/52.50c610c1.js"><link rel="prefetch" href="/assets/js/53.a76afd6f.js"><link rel="prefetch" href="/assets/js/54.0f87da0d.js"><link rel="prefetch" href="/assets/js/55.00db29fd.js"><link rel="prefetch" href="/assets/js/56.26322d78.js"><link rel="prefetch" href="/assets/js/57.e92a5bba.js"><link rel="prefetch" href="/assets/js/58.4f2f9990.js"><link rel="prefetch" href="/assets/js/59.f6d3db1a.js"><link rel="prefetch" href="/assets/js/60.60857555.js"><link rel="prefetch" href="/assets/js/61.6b38ebe4.js">
    <link rel="stylesheet" href="/assets/css/62.styles.28f5698d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      技术文档
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><a href="/" class="sidebar-link">技术文档</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>node学习</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Vue源码学习</span><span class="arrow up"></span></p><ul class="sidebar-group-items"><li><a href="/vue_resource/structure.html" class="sidebar-link">vue目录结构导读</a></li><li><a href="/vue_resource/start.html" class="sidebar-link">Vue之旅开始</a></li><li><a href="/vue_resource/options.html" class="sidebar-link">mergeOption的初始化与合并规则</a></li><li><a href="/vue_resource/init_data.html" class="sidebar-link">init_data</a></li><li><a href="/vue_resource/events.html" class="sidebar-link">内部事件初始始化与事件的实现</a></li><li><a href="/vue_resource/compile_el.html" class="sidebar-link">编译的整个过程与相关方法讲解</a></li><li><a href="/vue_resource/_compile_root.html" class="sidebar-link">编译其他节点</a></li><li><a href="/vue_resource/_compile_rest.html" class="sidebar-link">编译根节点</a></li><li><a href="/vue_resource/directive_base.html" class="sidebar-link">指令的创建与生成及更新</a></li><li><a href="/vue_resource/watch_observer.html" class="active sidebar-link">watch</a></li><li><a href="/vue_resource/batcher.html" class="sidebar-link">管理watcher队列</a></li><li><a href="/vue_resource/calculate.html" class="sidebar-link">表达式的运算与执行过滤</a></li><li><a href="/vue_resource/hook.html" class="sidebar-link">钩子函数的初始化与实现</a></li><li><a href="/vue_resource/transition.html" class="sidebar-link">transition实现讲解</a></li><li><a href="/vue_resource/dom.html" class="sidebar-link">DOM操作的几个方法实现</a></li><li><a href="/vue_resource/fragmentFactory.html" class="sidebar-link">工厂</a></li><li><a href="/vue_resource/directive_every.html" class="sidebar-link">内部几个指令的实现讲解</a></li><li><a href="/vue_resource/parse.html" class="sidebar-link">表达式解析的相关实现</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端常见问题</span><span class="arrow down"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h2 id="watch">watch</h2><p><img src="/assets/img/vue_watcher.96244100.png" alt="流程 text" title="title"></p><pre class="language-text"><code>
let uid = 0

/**
* 监听表达式, 收集依赖, 当表达式值改变时触发callback
* @param {Vue} vm
* @param {String} expression
* @param {Function} cb
* @param {Object} options
*                 - {Array} filters
*                 - {Boolean} twoWay
*                 - {Boolean} deep
*                 - {Boolean} user
*                 - {Boolean} sync  异步
*                 - {Boolean} lazy  延迟
*                 - {Function} [preProcess]
*                 - {Function} [postProcess]
* @constructor
*/

export default function Watcher (vm, expOrFn, cb, options) {
// mix in options
if (options) {
  extend(this, options)
}
var isFn = typeof expOrFn === 'function'
this.vm = vm
// 更新Vue当中_watchers
vm._watchers.push(this)
this.expression = isFn ? expOrFn.toString() : expOrFn
this.cb = cb
this.id = ++uid // uid for batching
this.active = true   // 是否存在
this.dirty = this.lazy // lazy watcher是否已获取数据, 未获取为true
this.deps = Object.create(null)
this.newDeps = null
this.prevError = null // 异步错误堆栈
// parse expression for getter/setter
if (isFn) {
  this.getter = expOrFn
  this.setter = undefined
} else {
  // 解析表达式, 获取其get与set
  var res = parseExpression(expOrFn, this.twoWay)
  this.getter = res.get
  this.setter = res.set
}
// 是否延迟获取值
this.value = this.lazy
  ? undefined
  : this.get()
// 初始化数据时, 监听调用vm._digest(true)避免触发
// state for avoiding false triggers for deep and Array
// watchers during vm._digest()
this.queued = this.shallow = false  // 是否为深度更新
}

/**
* Add a dependency to this directive.
* 添加一个dep到当前实例属性队列, 同时更新dep属性队列中的watcher实例
* @param {Dep} dep
*/

Watcher.prototype.addDep = function (dep) {
var id = dep.id
if (!this.newDeps[id]) {
  this.newDeps[id] = dep
  if (!this.deps[id]) {
    this.deps[id] = dep
    dep.addSub(this)
  }
}
}

/**
* Dep.target指向当前实例, 创建newDeps对象
*/

Watcher.prototype.beforeGet = function () {
Dep.target = this
this.newDeps = Object.create(null)
}

/**
* Evaluate the getter, and re-collect dependencies.
*/

Watcher.prototype.get = function () {
// 更新Dep.target 与 创建newDeps
this.beforeGet()
var scope = this.scope || this.vm
var value
// 执行getter获取值
try {
  value = this.getter.call(scope, scope)
} catch (e) {
  if (
    process.env.NODE_ENV !== 'production' &amp;&amp;
    config.warnExpressionErrors
  ) {
    warn(
      'Error when evaluating expression &quot;' +
      this.expression + '&quot;. ' +
      (config.debug
        ? ''
        : 'Turn on debug mode to see stack trace.'
      ), e
    )
  }
}
// &quot;touch&quot; every property so they are all tracked as
// dependencies for deep watching
if (this.deep) {
  traverse(value)
}
// 执行value预处理
if (this.preProcess) {
  value = this.preProcess(value)
}
// 执行filters
if (this.filters) {
  value = scope._applyFilters(value, null, this.filters, false)
}
// 结束处理
if (this.postProcess) {
  value = this.postProcess(value)
}
this.afterGet()
return value
}

/**
* Recrusively traverse an object to evoke all converted
* getters, so that every nested property inside the object
* is collected as a &quot;deep&quot; dependency.
*
* @param {*} val
*/

function traverse (val) {
var i, keys
if (isArray(val)) {
  i = val.length
  while (i--) traverse(val[i])
} else if (isObject(val)) {
  keys = Object.keys(val)
  i = keys.length
  while (i--) traverse(val[keys[i]])
}
}

/**
* Clean up for dependency collection.
* 清除依赖集合, 根据newDeps更新deps集合
*/

Watcher.prototype.afterGet = function () {
Dep.target = null
var ids = Object.keys(this.deps)
var i = ids.length
while (i--) {
  var id = ids[i]
  if (!this.newDeps[id]) {
    this.deps[id].removeSub(this)
  }
}
this.deps = this.newDeps
}

/**
* Set the corresponding value with the setter.
*
* @param {*} value
*/

Watcher.prototype.set = function (value) {
var scope = this.scope || this.vm
// 执行filters
if (this.filters) {
  value = scope._applyFilters(
    value, this.value, this.filters, true)
}
// 执行setter
try {
  this.setter.call(scope, scope, value)
} catch (e) {
  if (
    process.env.NODE_ENV !== 'production' &amp;&amp;
    config.warnExpressionErrors
  ) {
    warn(
      'Error when evaluating setter &quot;' +
      this.expression + '&quot;', e
    )
  }
}
// for循环时的指令实例
var forContext = scope.$forContext
if (forContext &amp;&amp; forContext.alias === this.expression) {
  if (forContext.filters) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'It seems you are using two-way binding on ' +
      'a v-for alias (' + this.expression + '), and the ' +
      'v-for has filters. This will not work properly. ' +
      'Either remove the filters or use an array of ' +
      'objects and bind to object properties instead.'
    )
    return
  }
  forContext._withLock(function () {
    if (scope.$key) { // original is an object
      forContext.rawValue[scope.$key] = value
    } else {
      //
      forContext.rawValue.$set(scope.$index, value)
    }
  })
}
}

/**
* 订单接口, 依赖发生改变时被调用
* @param {Boolean} shallow
*/

Watcher.prototype.update = function (shallow) {
// 延迟
if (this.lazy) {
  this.dirty = true
// 同步
} else if (this.sync || !config.async) {
  this.run()
} else {
  // if queued, only overwrite shallow with non-shallow,
  // but not the other way around.
  this.shallow = this.queued
    ? shallow
      ? this.shallow
      : false
    : !!shallow
  this.queued = true
  // record before-push error stack in debug mode
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' &amp;&amp; config.debug) {
    this.prevError = new Error('[vue] async stack trace')
  }
  // 更新watcher队列
  pushWatcher(this)
}
}

/**
* Batcher job interface.
* Will be called by the batcher.
*/

Watcher.prototype.run = function () {
if (this.active) {
  var value = this.get()
  if (
    value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated; but only do so if this is a
    // non-shallow update (caused by a vm digest).
    ((isObject(value) || this.deep) &amp;&amp; !this.shallow)
  ) {
    // set new value
    var oldValue = this.value
    this.value = value
    // in debug + async mode, when a watcher callbacks
    // throws, we also throw the saved before-push error
    // so the full cross-tick stack trace is available.
    var prevError = this.prevError
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp;
        config.debug &amp;&amp; prevError) {
      this.prevError = null
      try {
        this.cb.call(this.vm, value, oldValue)
      } catch (e) {
        nextTick(function () {
          throw prevError
        }, 0)
        throw e
      }
    } else {
      this.cb.call(this.vm, value, oldValue)
    }
  }
  this.queued = this.shallow = false
}
}

/**
* 计算watcher的值, lazy watcher, compute需计算时运用
*/

Watcher.prototype.evaluate = function () {
// avoid overwriting another watcher that is being
// collected.
var current = Dep.target
this.value = this.get()
this.dirty = false
Dep.target = current
}

/**
* Depend on all deps collected by this watcher.
*/

Watcher.prototype.depend = function () {
var depIds = Object.keys(this.deps)
var i = depIds.length
while (i--) {
  this.deps[depIds[i]].depend()
}
}

/**
* Remove self from all dependencies' subcriber list.
*/

Watcher.prototype.teardown = function () {
if (this.active) {
  // remove self from vm's watcher list
  // this is a somewhat expensive operation so we skip it
  // if the vm is being destroyed or is performing a v-for
  // re-render (the watcher list is then filtered by v-for).
  if (!this.vm._isBeingDestroyed &amp;&amp; !this.vm._vForRemoving) {
    this.vm._watchers.$remove(this)
  }
  var depIds = Object.keys(this.deps)
  var i = depIds.length
  while (i--) {
    this.deps[depIds[i]].removeSub(this)
  }
  this.active = false
  this.vm = this.cb = this.value = null
}
}


Vue.prototype.$watch = function (expOrFn, cb, options) {
  var vm = this
  var parsed
  if (typeof expOrFn === 'string') {
    parsed = parseDirective(expOrFn)
    expOrFn = parsed.expression
  }
  var watcher = new Watcher(vm, expOrFn, cb, {
    deep: options &amp;&amp; options.deep,
    sync: options &amp;&amp; options.sync,
    filters: parsed &amp;&amp; parsed.filters,
    user: !options || options.user !== false
  })
  if (options &amp;&amp; options.immediate) {
    cb.call(vm, watcher.value)
  }
  return function unwatchFn () {
    watcher.teardown()
  }
}
</code></pre><h2 id="提供的几个方法-更新数据都会监听并通知进行watcher更新">提供的几个方法, 更新数据都会监听并通知进行watcher更新</h2><pre class="language-text"><code>
/**
  * Intercept mutating methods and emit events
  */

;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length
    var args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    var result = original.apply(this, args)
    var ob = this.__ob__
    var inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})

/**
  * Swap the element at the given index with a new value
  * and emits corresponding event.
  *
  * @param {Number} index
  * @param {*} val
  * @return {*} - replaced element
  */

def(
  arrayProto,
  '$set',
  function $set (index, val) {
    if (index &gt;= this.length) {
      this.length = Number(index) + 1
    }
    return this.splice(index, 1, val)[0]
  }
)

/**
  * Convenience method to remove the element at given index.
  *
  * @param {Number} index
  * @param {*} val
  */

def(
  arrayProto,
  '$remove',
  function $remove (item) {
    /* istanbul ignore if */
    if (!this.length) return
    var index = indexOf(this, item)
    if (index &gt; -1) {
      return this.splice(index, 1)
    }
  }
)
</code></pre><h2 id="observer-利用object-defineproperty添加get与set-通过递归将甩有属性添加get与set">observer 利用Object.defineProperty添加get与set, 通过递归将甩有属性添加get与set.</h2><pre class="language-text"><code>
export function defineReactive (obj, key, val) {
  var dep = new Dep()

  // cater for pre-defined getter/setters
  var getter, setter
  if (config.convertAllProperties) {
    var property = Object.getOwnPropertyDescriptor(obj, key)
    if (property &amp;&amp; property.configurable === false) {
      return
    }
    getter = property &amp;&amp; property.get
    setter = property &amp;&amp; property.set
  }

  var childOb = observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val
      // 判断是不是watcher.get调用
      if (Dep.target) {
        // dep更新到watcher的属性队列中
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
        }
        if (isArray(value)) {
          for (var e, i = 0, l = value.length; i &lt; l; i++) {
            e = value[i]
            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val
      if (newVal === value) {
        return
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = observe(newVal)
      // 进行赋值时会触发watcher更新
      dep.notify()
    }
  })
}
  export function Observer (value) {
  this.value = value
  this.dep = new Dep()
  def(value, '__ob__', this)
  if (isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment
    augment(value, arrayMethods, arrayKeys)
    this.observeArray(value)
  } else {
    this.walk(value)
  }
}

// Instance methods

/**
  * Walk through each property and convert them into
  * getter/setters. This method should only be called when
  * value type is Object.
  *
  * @param {Object} obj
  */

Observer.prototype.walk = function (obj) {
  var keys = Object.keys(obj)
  for (var i = 0, l = keys.length; i &lt; l; i++) {
    this.convert(keys[i], obj[keys[i]])
  }
}

/**
  * Observe a list of Array items.
  *
  * @param {Array} items
  */

Observer.prototype.observeArray = function (items) {
  for (var i = 0, l = items.length; i &lt; l; i++) {
    observe(items[i])
  }
}

/**
  * Convert a property into getter/setter so we can emit
  * the events when the property is accessed/changed.
  *
  * @param {String} key
  * @param {*} val
  */

Observer.prototype.convert = function (key, val) {
  defineReactive(this.value, key, val)
}

/**
  * Add an owner vm, so that when $set/$delete mutations
  * happen we can notify owner vms to proxy the keys and
  * digest the watchers. This is only called when the object
  * is observed as an instance's root $data.
  *
  * @param {Vue} vm
  */

Observer.prototype.addVm = function (vm) {
  (this.vms || (this.vms = [])).push(vm)
}

/**
  * Remove an owner vm. This is called when the object is
  * swapped out as an instance's $data object.
  *
  * @param {Vue} vm
  */

Observer.prototype.removeVm = function (vm) {
  this.vms.$remove(vm)
}

// helpers

/**
  * Augment an target Object or Array by intercepting
  * the prototype chain using __proto__
  *
  * @param {Object|Array} target
  * @param {Object} proto
  */

function protoAugment (target, src) {
  target.__proto__ = src
}

/**
  * Augment an target Object or Array by defining
  * hidden properties.
  *
  * @param {Object|Array} target
  * @param {Object} proto
  */

function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i &lt; l; i++) {
    var key = keys[i]
    def(target, key, src[key])
  }
}

/**
  * Attempt to create an observer instance for a value,
  * returns the new observer if successfully observed,
  * or the existing observer if the value already has one.
  *
  * @param {*} value
  * @param {Vue} [vm]
  * @return {Observer|undefined}
  * @static
  */

export function observe (value, vm) {
  if (!value || typeof value !== 'object') {
    return
  }
  var ob
  if (
    hasOwn(value, '__ob__') &amp;&amp;
    value.__ob__ instanceof Observer
  ) {
    ob = value.__ob__
  } else if (
    (isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (ob &amp;&amp; vm) {
    ob.addVm(vm)
  }
  return ob
}

/**
  * Set a property on an object. Adds the new property and
  * triggers change notification if the property doesn't
  * already exist.
  *
  * @param {Object} obj
  * @param {String} key
  * @param {*} val
  * @public
  */

export function set (obj, key, val) {
  if (hasOwn(obj, key)) {
    obj[key] = val
    return
  }
  if (obj._isVue) {
    set(obj._data, key, val)
    return
  }
  var ob = obj.__ob__
  if (!ob) {
    obj[key] = val
    return
  }
  ob.convert(key, val)
  ob.dep.notify()
  if (ob.vms) {
    var i = ob.vms.length
    while (i--) {
      var vm = ob.vms[i]
      vm._proxy(key)
      vm._digest()
    }
  }
  return val
}

/**
  * Delete a property and trigger change if necessary.
  *
  * @param {Object} obj
  * @param {String} key
  */

export function del (obj, key) {
  if (!hasOwn(obj, key)) {
    return
  }
  delete obj[key]
  var ob = obj.__ob__
  if (!ob) {
    return
  }
  ob.dep.notify()
  if (ob.vms) {
    var i = ob.vms.length
    while (i--) {
      var vm = ob.vms[i]
      vm._unproxy(key)
      vm._digest()
    }
  }
}

/**
* Get the value from an expression on this vm.
*
* @param {String} exp
* @param {Boolean} [asStatement]
* @return {*}
*/

Vue.prototype.$get = function (exp, asStatement) {
var res = parseExpression(exp)
if (res) {
  if (asStatement &amp;&amp; !isSimplePath(exp)) {
    var self = this
    return function statementHandler () {
      self.$arguments = toArray(arguments)
      var result = res.get.call(self, self)
      self.$arguments = null
      return result
    }
  } else {
    try {
      return res.get.call(this, this)
    } catch (e) {}
  }
}
}

/**
* Set the value from an expression on this vm.
* The expression must be a valid left-hand
* expression in an assignment.
*
* @param {String} exp
* @param {*} val
*/

Vue.prototype.$set = function (exp, val) {
    var res = parseExpression(exp, true)
    if (res &amp;&amp; res.set) {
      res.set.call(this, this, val)
    }
}

/**
* Delete a property on the VM
*
* @param {String} key
*/

Vue.prototype.$delete = function (key) {
    del(this._data, key)
}
</code></pre></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/vue_resource/directive_base.html" class="prev">
          指令的创建与生成及更新
        </a></span><span class="next"><a href="/vue_resource/batcher.html">
          管理watcher队列
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/0.07822d9a.js" defer></script><script src="/assets/js/app.9bd0b60f.js" defer></script>
  </body>
</html>
