<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档 | watch</title>
    <meta name="description" content="偏重前端与node的技术文档">
    
    
    <link rel="preload" href="/assets/css/104.styles.28e83be5.css" as="style"><link rel="preload" href="/assets/js/app.a411c98e.js" as="script"><link rel="preload" href="/assets/js/0.0f6d0243.js" as="script"><link rel="prefetch" href="/assets/js/46.b6751e6a.js"><link rel="prefetch" href="/assets/js/1.2d9e0877.js"><link rel="prefetch" href="/assets/js/2.a66146ee.js"><link rel="prefetch" href="/assets/js/3.20ebc865.js"><link rel="prefetch" href="/assets/js/4.ec42dc49.js"><link rel="prefetch" href="/assets/js/5.91016e26.js"><link rel="prefetch" href="/assets/js/6.786c2dc9.js"><link rel="prefetch" href="/assets/js/7.acf90bd2.js"><link rel="prefetch" href="/assets/js/8.4e2614b5.js"><link rel="prefetch" href="/assets/js/9.622c1670.js"><link rel="prefetch" href="/assets/js/10.414913ea.js"><link rel="prefetch" href="/assets/js/11.25e21999.js"><link rel="prefetch" href="/assets/js/12.9e7cdbb6.js"><link rel="prefetch" href="/assets/js/13.04364b10.js"><link rel="prefetch" href="/assets/js/14.e5e1da67.js"><link rel="prefetch" href="/assets/js/15.2a158eb5.js"><link rel="prefetch" href="/assets/js/16.34214a90.js"><link rel="prefetch" href="/assets/js/17.e99acbae.js"><link rel="prefetch" href="/assets/js/18.af3a9615.js"><link rel="prefetch" href="/assets/js/19.1ceb0d9a.js"><link rel="prefetch" href="/assets/js/20.53d731ba.js"><link rel="prefetch" href="/assets/js/21.3c945e37.js"><link rel="prefetch" href="/assets/js/22.c4d43157.js"><link rel="prefetch" href="/assets/js/23.79df7ce3.js"><link rel="prefetch" href="/assets/js/24.fc2b557a.js"><link rel="prefetch" href="/assets/js/25.9d106f6b.js"><link rel="prefetch" href="/assets/js/26.317a0b3a.js"><link rel="prefetch" href="/assets/js/27.851a7fdf.js"><link rel="prefetch" href="/assets/js/28.f4ccd57a.js"><link rel="prefetch" href="/assets/js/29.33e54060.js"><link rel="prefetch" href="/assets/js/30.2f1b1242.js"><link rel="prefetch" href="/assets/js/31.e1dfa41b.js"><link rel="prefetch" href="/assets/js/32.9fe9dbec.js"><link rel="prefetch" href="/assets/js/33.77d438f1.js"><link rel="prefetch" href="/assets/js/34.ef934f7a.js"><link rel="prefetch" href="/assets/js/35.6854c113.js"><link rel="prefetch" href="/assets/js/36.d1a58c8c.js"><link rel="prefetch" href="/assets/js/37.1d501b03.js"><link rel="prefetch" href="/assets/js/38.78816a29.js"><link rel="prefetch" href="/assets/js/39.ecc0e461.js"><link rel="prefetch" href="/assets/js/40.67673e52.js"><link rel="prefetch" href="/assets/js/41.72ee2d0f.js"><link rel="prefetch" href="/assets/js/42.70eaf18e.js"><link rel="prefetch" href="/assets/js/43.577eeff1.js"><link rel="prefetch" href="/assets/js/44.173f820f.js"><link rel="prefetch" href="/assets/js/45.f48c5526.js"><link rel="prefetch" href="/assets/js/47.4954a77f.js"><link rel="prefetch" href="/assets/js/48.72651a9e.js"><link rel="prefetch" href="/assets/js/49.001ca83a.js"><link rel="prefetch" href="/assets/js/50.9fb48b79.js"><link rel="prefetch" href="/assets/js/51.1969cfec.js"><link rel="prefetch" href="/assets/js/52.f9ca48be.js"><link rel="prefetch" href="/assets/js/53.4a2715eb.js"><link rel="prefetch" href="/assets/js/54.e341f839.js"><link rel="prefetch" href="/assets/js/55.73b820e7.js"><link rel="prefetch" href="/assets/js/56.f60d7fd6.js"><link rel="prefetch" href="/assets/js/57.f5dcdbe2.js"><link rel="prefetch" href="/assets/js/58.9d6fc9aa.js"><link rel="prefetch" href="/assets/js/59.e07fe776.js"><link rel="prefetch" href="/assets/js/60.789eda2a.js"><link rel="prefetch" href="/assets/js/61.d1f2f4cd.js"><link rel="prefetch" href="/assets/js/62.15126829.js"><link rel="prefetch" href="/assets/js/63.6280e165.js"><link rel="prefetch" href="/assets/js/64.f431af28.js"><link rel="prefetch" href="/assets/js/65.dda8f427.js"><link rel="prefetch" href="/assets/js/66.2b568d90.js"><link rel="prefetch" href="/assets/js/67.3dab9aaa.js"><link rel="prefetch" href="/assets/js/68.45689b74.js"><link rel="prefetch" href="/assets/js/69.e5f83e7d.js"><link rel="prefetch" href="/assets/js/70.4c9314d9.js"><link rel="prefetch" href="/assets/js/71.88639d66.js"><link rel="prefetch" href="/assets/js/72.9825a8bc.js"><link rel="prefetch" href="/assets/js/73.c41e53a1.js"><link rel="prefetch" href="/assets/js/74.7454890c.js"><link rel="prefetch" href="/assets/js/75.84bc90b4.js"><link rel="prefetch" href="/assets/js/76.ca10b7a8.js"><link rel="prefetch" href="/assets/js/77.817d4d0f.js"><link rel="prefetch" href="/assets/js/78.931b7bc1.js"><link rel="prefetch" href="/assets/js/79.67e703e0.js"><link rel="prefetch" href="/assets/js/80.bba3fb8a.js"><link rel="prefetch" href="/assets/js/81.3a488949.js"><link rel="prefetch" href="/assets/js/82.2874a895.js"><link rel="prefetch" href="/assets/js/83.de563bc3.js"><link rel="prefetch" href="/assets/js/84.48150ecf.js"><link rel="prefetch" href="/assets/js/85.bcc25395.js"><link rel="prefetch" href="/assets/js/86.19e795ae.js"><link rel="prefetch" href="/assets/js/87.4dba67cf.js"><link rel="prefetch" href="/assets/js/88.2a7b9707.js"><link rel="prefetch" href="/assets/js/89.93bda388.js"><link rel="prefetch" href="/assets/js/90.97a6064b.js"><link rel="prefetch" href="/assets/js/91.37ce3856.js"><link rel="prefetch" href="/assets/js/92.cf736dd2.js"><link rel="prefetch" href="/assets/js/93.55005712.js"><link rel="prefetch" href="/assets/js/94.149acba3.js"><link rel="prefetch" href="/assets/js/95.d204cbb7.js"><link rel="prefetch" href="/assets/js/96.51bde9ee.js"><link rel="prefetch" href="/assets/js/97.b6d54691.js"><link rel="prefetch" href="/assets/js/98.244fcc85.js"><link rel="prefetch" href="/assets/js/99.2853e994.js"><link rel="prefetch" href="/assets/js/100.ea317b53.js"><link rel="prefetch" href="/assets/js/101.edad34de.js"><link rel="prefetch" href="/assets/js/102.9e7d2641.js"><link rel="prefetch" href="/assets/js/103.fa6aeec2.js">
    <link rel="stylesheet" href="/assets/css/104.styles.28e83be5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      技术文档
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><a href="/" class="sidebar-link">技术文档</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>node学习</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>leetcode完成的好的题目</span><!----></p><ul class="sidebar-group-items"><li><a href="/LeetCode/regex.html" class="sidebar-link">正则相关的题目</a></li><li><a href="/LeetCode/string.html" class="sidebar-link">String 相关的题目</a></li><li><a href="/LeetCode/link.html" class="sidebar-link">链表</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6学习</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>Vue源码学习</span><!----></p><ul class="sidebar-group-items"><li><a href="/vue_resource/structure.html" class="sidebar-link">vue目录结构导读</a></li><li><a href="/vue_resource/start.html" class="sidebar-link">Vue之旅开始</a></li><li><a href="/vue_resource/options.html" class="sidebar-link">mergeOption的初始化与合并规则</a></li><li><a href="/vue_resource/init_data.html" class="sidebar-link">init_data</a></li><li><a href="/vue_resource/events.html" class="sidebar-link">内部事件初始始化与事件的实现</a></li><li><a href="/vue_resource/compile_el.html" class="sidebar-link">编译的整个过程与相关方法讲解</a></li><li><a href="/vue_resource/_compile_root.html" class="sidebar-link">编译其他节点</a></li><li><a href="/vue_resource/_compile_rest.html" class="sidebar-link">编译根节点</a></li><li><a href="/vue_resource/directive_base.html" class="sidebar-link">指令的创建与生成及更新</a></li><li><a href="/vue_resource/watch_observer.html" class="active sidebar-link">watch</a></li><li><a href="/vue_resource/batcher.html" class="sidebar-link">管理watcher队列</a></li><li><a href="/vue_resource/calculate.html" class="sidebar-link">表达式的运算与执行过滤</a></li><li><a href="/vue_resource/hook.html" class="sidebar-link">钩子函数的初始化与实现</a></li><li><a href="/vue_resource/transition.html" class="sidebar-link">transition实现讲解</a></li><li><a href="/vue_resource/dom.html" class="sidebar-link">DOM操作的几个方法实现</a></li><li><a href="/vue_resource/fragmentFactory.html" class="sidebar-link">工厂</a></li><li><a href="/vue_resource/directive_every.html" class="sidebar-link">内部几个指令的实现讲解</a></li><li><a href="/vue_resource/parse.html" class="sidebar-link">表达式解析的相关实现</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端常见问题</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端基础</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>算法</span><!----></p><ul class="sidebar-group-items"><li><a href="/arithmetic/reg_match.html" class="sidebar-link">正则匹配模式</a></li><li><a href="/arithmetic/search_str.html" class="sidebar-link">正则查找子串</a></li><li><a href="/arithmetic/callStack.html" class="sidebar-link">递归调用栈及尾递归的优化</a></li><li><a href="/arithmetic/sort.html" class="sidebar-link">排序算法</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h2 id="watch">watch</h2><p><img src="/assets/img/vue_watcher.96244100.png" alt="流程 text" title="title"></p><pre class="language-text"><code>
let uid = 0

/**
* 监听表达式, 收集依赖, 当表达式值改变时触发callback
* @param {Vue} vm
* @param {String} expression
* @param {Function} cb
* @param {Object} options
*                 - {Array} filters
*                 - {Boolean} twoWay
*                 - {Boolean} deep
*                 - {Boolean} user
*                 - {Boolean} sync  异步
*                 - {Boolean} lazy  延迟
*                 - {Function} [preProcess]
*                 - {Function} [postProcess]
* @constructor
*/

export default function Watcher (vm, expOrFn, cb, options) {
// mix in options
if (options) {
  extend(this, options)
}
var isFn = typeof expOrFn === 'function'
this.vm = vm
// 更新Vue当中_watchers
vm._watchers.push(this)
this.expression = isFn ? expOrFn.toString() : expOrFn
this.cb = cb
this.id = ++uid // uid for batching
this.active = true   // 是否存在
this.dirty = this.lazy // lazy watcher是否已获取数据, 未获取为true
this.deps = Object.create(null)
this.newDeps = null
this.prevError = null // 异步错误堆栈
// parse expression for getter/setter
if (isFn) {
  this.getter = expOrFn
  this.setter = undefined
} else {
  // 解析表达式, 获取其get与set
  var res = parseExpression(expOrFn, this.twoWay)
  this.getter = res.get
  this.setter = res.set
}
// 是否延迟获取值
this.value = this.lazy
  ? undefined
  : this.get()
// 初始化数据时, 监听调用vm._digest(true)避免触发
// state for avoiding false triggers for deep and Array
// watchers during vm._digest()
this.queued = this.shallow = false  // 是否为深度更新
}

/**
* Add a dependency to this directive.
* 添加一个dep到当前实例属性队列, 同时更新dep属性队列中的watcher实例
* @param {Dep} dep
*/

Watcher.prototype.addDep = function (dep) {
var id = dep.id
if (!this.newDeps[id]) {
  this.newDeps[id] = dep
  if (!this.deps[id]) {
    this.deps[id] = dep
    dep.addSub(this)
  }
}
}

/**
* Dep.target指向当前实例, 创建newDeps对象
*/

Watcher.prototype.beforeGet = function () {
Dep.target = this
this.newDeps = Object.create(null)
}

/**
* Evaluate the getter, and re-collect dependencies.
*/

Watcher.prototype.get = function () {
// 更新Dep.target 与 创建newDeps
this.beforeGet()
var scope = this.scope || this.vm
var value
// 执行getter获取值
try {
  value = this.getter.call(scope, scope)
} catch (e) {
  if (
    process.env.NODE_ENV !== 'production' &amp;&amp;
    config.warnExpressionErrors
  ) {
    warn(
      'Error when evaluating expression &quot;' +
      this.expression + '&quot;. ' +
      (config.debug
        ? ''
        : 'Turn on debug mode to see stack trace.'
      ), e
    )
  }
}
// &quot;touch&quot; every property so they are all tracked as
// dependencies for deep watching
if (this.deep) {
  traverse(value)
}
// 执行value预处理
if (this.preProcess) {
  value = this.preProcess(value)
}
// 执行filters
if (this.filters) {
  value = scope._applyFilters(value, null, this.filters, false)
}
// 结束处理
if (this.postProcess) {
  value = this.postProcess(value)
}
this.afterGet()
return value
}

/**
* Recrusively traverse an object to evoke all converted
* getters, so that every nested property inside the object
* is collected as a &quot;deep&quot; dependency.
*
* @param {*} val
*/

function traverse (val) {
var i, keys
if (isArray(val)) {
  i = val.length
  while (i--) traverse(val[i])
} else if (isObject(val)) {
  keys = Object.keys(val)
  i = keys.length
  while (i--) traverse(val[keys[i]])
}
}

/**
* Clean up for dependency collection.
* 清除依赖集合, 根据newDeps更新deps集合
*/

Watcher.prototype.afterGet = function () {
Dep.target = null
var ids = Object.keys(this.deps)
var i = ids.length
while (i--) {
  var id = ids[i]
  if (!this.newDeps[id]) {
    this.deps[id].removeSub(this)
  }
}
this.deps = this.newDeps
}

/**
* Set the corresponding value with the setter.
*
* @param {*} value
*/

Watcher.prototype.set = function (value) {
var scope = this.scope || this.vm
// 执行filters
if (this.filters) {
  value = scope._applyFilters(
    value, this.value, this.filters, true)
}
// 执行setter
try {
  this.setter.call(scope, scope, value)
} catch (e) {
  if (
    process.env.NODE_ENV !== 'production' &amp;&amp;
    config.warnExpressionErrors
  ) {
    warn(
      'Error when evaluating setter &quot;' +
      this.expression + '&quot;', e
    )
  }
}
// for循环时的指令实例
var forContext = scope.$forContext
if (forContext &amp;&amp; forContext.alias === this.expression) {
  if (forContext.filters) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'It seems you are using two-way binding on ' +
      'a v-for alias (' + this.expression + '), and the ' +
      'v-for has filters. This will not work properly. ' +
      'Either remove the filters or use an array of ' +
      'objects and bind to object properties instead.'
    )
    return
  }
  forContext._withLock(function () {
    if (scope.$key) { // original is an object
      forContext.rawValue[scope.$key] = value
    } else {
      //
      forContext.rawValue.$set(scope.$index, value)
    }
  })
}
}

/**
* 订单接口, 依赖发生改变时被调用
* @param {Boolean} shallow
*/

Watcher.prototype.update = function (shallow) {
// 延迟
if (this.lazy) {
  this.dirty = true
// 同步
} else if (this.sync || !config.async) {
  this.run()
} else {
  // if queued, only overwrite shallow with non-shallow,
  // but not the other way around.
  this.shallow = this.queued
    ? shallow
      ? this.shallow
      : false
    : !!shallow
  this.queued = true
  // record before-push error stack in debug mode
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' &amp;&amp; config.debug) {
    this.prevError = new Error('[vue] async stack trace')
  }
  // 更新watcher队列
  pushWatcher(this)
}
}

/**
* Batcher job interface.
* Will be called by the batcher.
*/

Watcher.prototype.run = function () {
if (this.active) {
  var value = this.get()
  if (
    value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated; but only do so if this is a
    // non-shallow update (caused by a vm digest).
    ((isObject(value) || this.deep) &amp;&amp; !this.shallow)
  ) {
    // set new value
    var oldValue = this.value
    this.value = value
    // in debug + async mode, when a watcher callbacks
    // throws, we also throw the saved before-push error
    // so the full cross-tick stack trace is available.
    var prevError = this.prevError
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp;
        config.debug &amp;&amp; prevError) {
      this.prevError = null
      try {
        this.cb.call(this.vm, value, oldValue)
      } catch (e) {
        nextTick(function () {
          throw prevError
        }, 0)
        throw e
      }
    } else {
      this.cb.call(this.vm, value, oldValue)
    }
  }
  this.queued = this.shallow = false
}
}

/**
* 计算watcher的值, lazy watcher, compute需计算时运用
*/

Watcher.prototype.evaluate = function () {
// avoid overwriting another watcher that is being
// collected.
var current = Dep.target
this.value = this.get()
this.dirty = false
Dep.target = current
}

/**
* Depend on all deps collected by this watcher.
*/

Watcher.prototype.depend = function () {
var depIds = Object.keys(this.deps)
var i = depIds.length
while (i--) {
  this.deps[depIds[i]].depend()
}
}

/**
* Remove self from all dependencies' subcriber list.
*/

Watcher.prototype.teardown = function () {
if (this.active) {
  // remove self from vm's watcher list
  // this is a somewhat expensive operation so we skip it
  // if the vm is being destroyed or is performing a v-for
  // re-render (the watcher list is then filtered by v-for).
  if (!this.vm._isBeingDestroyed &amp;&amp; !this.vm._vForRemoving) {
    this.vm._watchers.$remove(this)
  }
  var depIds = Object.keys(this.deps)
  var i = depIds.length
  while (i--) {
    this.deps[depIds[i]].removeSub(this)
  }
  this.active = false
  this.vm = this.cb = this.value = null
}
}


Vue.prototype.$watch = function (expOrFn, cb, options) {
  var vm = this
  var parsed
  if (typeof expOrFn === 'string') {
    parsed = parseDirective(expOrFn)
    expOrFn = parsed.expression
  }
  var watcher = new Watcher(vm, expOrFn, cb, {
    deep: options &amp;&amp; options.deep,
    sync: options &amp;&amp; options.sync,
    filters: parsed &amp;&amp; parsed.filters,
    user: !options || options.user !== false
  })
  if (options &amp;&amp; options.immediate) {
    cb.call(vm, watcher.value)
  }
  return function unwatchFn () {
    watcher.teardown()
  }
}
</code></pre><h2 id="提供的几个方法-更新数据都会监听并通知进行watcher更新">提供的几个方法, 更新数据都会监听并通知进行watcher更新</h2><pre class="language-text"><code>
/**
  * Intercept mutating methods and emit events
  */

;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length
    var args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    var result = original.apply(this, args)
    var ob = this.__ob__
    var inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})

/**
  * Swap the element at the given index with a new value
  * and emits corresponding event.
  *
  * @param {Number} index
  * @param {*} val
  * @return {*} - replaced element
  */

def(
  arrayProto,
  '$set',
  function $set (index, val) {
    if (index &gt;= this.length) {
      this.length = Number(index) + 1
    }
    return this.splice(index, 1, val)[0]
  }
)

/**
  * Convenience method to remove the element at given index.
  *
  * @param {Number} index
  * @param {*} val
  */

def(
  arrayProto,
  '$remove',
  function $remove (item) {
    /* istanbul ignore if */
    if (!this.length) return
    var index = indexOf(this, item)
    if (index &gt; -1) {
      return this.splice(index, 1)
    }
  }
)
</code></pre><h2 id="observer-利用object-defineproperty添加get与set-通过递归将甩有属性添加get与set">observer 利用Object.defineProperty添加get与set, 通过递归将甩有属性添加get与set.</h2><pre class="language-text"><code>
export function defineReactive (obj, key, val) {
  var dep = new Dep()

  // cater for pre-defined getter/setters
  var getter, setter
  if (config.convertAllProperties) {
    var property = Object.getOwnPropertyDescriptor(obj, key)
    if (property &amp;&amp; property.configurable === false) {
      return
    }
    getter = property &amp;&amp; property.get
    setter = property &amp;&amp; property.set
  }

  var childOb = observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val
      // 判断是不是watcher.get调用
      if (Dep.target) {
        // dep更新到watcher的属性队列中
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
        }
        if (isArray(value)) {
          for (var e, i = 0, l = value.length; i &lt; l; i++) {
            e = value[i]
            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val
      if (newVal === value) {
        return
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = observe(newVal)
      // 进行赋值时会触发watcher更新
      dep.notify()
    }
  })
}
  export function Observer (value) {
  this.value = value
  this.dep = new Dep()
  def(value, '__ob__', this)
  if (isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment
    augment(value, arrayMethods, arrayKeys)
    this.observeArray(value)
  } else {
    this.walk(value)
  }
}

// Instance methods

/**
  * Walk through each property and convert them into
  * getter/setters. This method should only be called when
  * value type is Object.
  *
  * @param {Object} obj
  */

Observer.prototype.walk = function (obj) {
  var keys = Object.keys(obj)
  for (var i = 0, l = keys.length; i &lt; l; i++) {
    this.convert(keys[i], obj[keys[i]])
  }
}

/**
  * Observe a list of Array items.
  *
  * @param {Array} items
  */

Observer.prototype.observeArray = function (items) {
  for (var i = 0, l = items.length; i &lt; l; i++) {
    observe(items[i])
  }
}

/**
  * Convert a property into getter/setter so we can emit
  * the events when the property is accessed/changed.
  *
  * @param {String} key
  * @param {*} val
  */

Observer.prototype.convert = function (key, val) {
  defineReactive(this.value, key, val)
}

/**
  * Add an owner vm, so that when $set/$delete mutations
  * happen we can notify owner vms to proxy the keys and
  * digest the watchers. This is only called when the object
  * is observed as an instance's root $data.
  *
  * @param {Vue} vm
  */

Observer.prototype.addVm = function (vm) {
  (this.vms || (this.vms = [])).push(vm)
}

/**
  * Remove an owner vm. This is called when the object is
  * swapped out as an instance's $data object.
  *
  * @param {Vue} vm
  */

Observer.prototype.removeVm = function (vm) {
  this.vms.$remove(vm)
}

// helpers

/**
  * Augment an target Object or Array by intercepting
  * the prototype chain using __proto__
  *
  * @param {Object|Array} target
  * @param {Object} proto
  */

function protoAugment (target, src) {
  target.__proto__ = src
}

/**
  * Augment an target Object or Array by defining
  * hidden properties.
  *
  * @param {Object|Array} target
  * @param {Object} proto
  */

function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i &lt; l; i++) {
    var key = keys[i]
    def(target, key, src[key])
  }
}

/**
  * Attempt to create an observer instance for a value,
  * returns the new observer if successfully observed,
  * or the existing observer if the value already has one.
  *
  * @param {*} value
  * @param {Vue} [vm]
  * @return {Observer|undefined}
  * @static
  */

export function observe (value, vm) {
  if (!value || typeof value !== 'object') {
    return
  }
  var ob
  if (
    hasOwn(value, '__ob__') &amp;&amp;
    value.__ob__ instanceof Observer
  ) {
    ob = value.__ob__
  } else if (
    (isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (ob &amp;&amp; vm) {
    ob.addVm(vm)
  }
  return ob
}

/**
  * Set a property on an object. Adds the new property and
  * triggers change notification if the property doesn't
  * already exist.
  *
  * @param {Object} obj
  * @param {String} key
  * @param {*} val
  * @public
  */

export function set (obj, key, val) {
  if (hasOwn(obj, key)) {
    obj[key] = val
    return
  }
  if (obj._isVue) {
    set(obj._data, key, val)
    return
  }
  var ob = obj.__ob__
  if (!ob) {
    obj[key] = val
    return
  }
  ob.convert(key, val)
  ob.dep.notify()
  if (ob.vms) {
    var i = ob.vms.length
    while (i--) {
      var vm = ob.vms[i]
      vm._proxy(key)
      vm._digest()
    }
  }
  return val
}

/**
  * Delete a property and trigger change if necessary.
  *
  * @param {Object} obj
  * @param {String} key
  */

export function del (obj, key) {
  if (!hasOwn(obj, key)) {
    return
  }
  delete obj[key]
  var ob = obj.__ob__
  if (!ob) {
    return
  }
  ob.dep.notify()
  if (ob.vms) {
    var i = ob.vms.length
    while (i--) {
      var vm = ob.vms[i]
      vm._unproxy(key)
      vm._digest()
    }
  }
}

/**
* Get the value from an expression on this vm.
*
* @param {String} exp
* @param {Boolean} [asStatement]
* @return {*}
*/

Vue.prototype.$get = function (exp, asStatement) {
var res = parseExpression(exp)
if (res) {
  if (asStatement &amp;&amp; !isSimplePath(exp)) {
    var self = this
    return function statementHandler () {
      self.$arguments = toArray(arguments)
      var result = res.get.call(self, self)
      self.$arguments = null
      return result
    }
  } else {
    try {
      return res.get.call(this, this)
    } catch (e) {}
  }
}
}

/**
* Set the value from an expression on this vm.
* The expression must be a valid left-hand
* expression in an assignment.
*
* @param {String} exp
* @param {*} val
*/

Vue.prototype.$set = function (exp, val) {
    var res = parseExpression(exp, true)
    if (res &amp;&amp; res.set) {
      res.set.call(this, this, val)
    }
}

/**
* Delete a property on the VM
*
* @param {String} key
*/

Vue.prototype.$delete = function (key) {
    del(this._data, key)
}
</code></pre></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/vue_resource/directive_base.html" class="prev">
          指令的创建与生成及更新
        </a></span><span class="next"><a href="/vue_resource/batcher.html">
          管理watcher队列
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/0.0f6d0243.js" defer></script><script src="/assets/js/app.a411c98e.js" defer></script>
  </body>
</html>
