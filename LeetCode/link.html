<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档 | 链表</title>
    <meta name="description" content="偏重前端与node的技术文档">
    
    
    <link rel="preload" href="/assets/css/104.styles.28e83be5.css" as="style"><link rel="preload" href="/assets/js/app.7cebdd4c.js" as="script"><link rel="preload" href="/assets/js/102.9e7d2641.js" as="script"><link rel="prefetch" href="/assets/js/46.da7d38b9.js"><link rel="prefetch" href="/assets/js/0.6676b856.js"><link rel="prefetch" href="/assets/js/1.4fc8cfb9.js"><link rel="prefetch" href="/assets/js/2.d64288f4.js"><link rel="prefetch" href="/assets/js/3.2c08947e.js"><link rel="prefetch" href="/assets/js/4.192dc951.js"><link rel="prefetch" href="/assets/js/5.3492e24b.js"><link rel="prefetch" href="/assets/js/6.f9b9cea0.js"><link rel="prefetch" href="/assets/js/7.1b8c78b4.js"><link rel="prefetch" href="/assets/js/8.68c3578d.js"><link rel="prefetch" href="/assets/js/9.d285c9f9.js"><link rel="prefetch" href="/assets/js/10.3454724d.js"><link rel="prefetch" href="/assets/js/11.ac850cee.js"><link rel="prefetch" href="/assets/js/12.751100ec.js"><link rel="prefetch" href="/assets/js/13.cc757319.js"><link rel="prefetch" href="/assets/js/14.000bf79d.js"><link rel="prefetch" href="/assets/js/15.34621574.js"><link rel="prefetch" href="/assets/js/16.af41d0a2.js"><link rel="prefetch" href="/assets/js/17.40791ea6.js"><link rel="prefetch" href="/assets/js/18.7325f026.js"><link rel="prefetch" href="/assets/js/19.e4e4dc20.js"><link rel="prefetch" href="/assets/js/20.c72ce3e9.js"><link rel="prefetch" href="/assets/js/21.f3702c0e.js"><link rel="prefetch" href="/assets/js/22.67556bb2.js"><link rel="prefetch" href="/assets/js/23.afe01d5b.js"><link rel="prefetch" href="/assets/js/24.7d7fe4fc.js"><link rel="prefetch" href="/assets/js/25.ff1c5b42.js"><link rel="prefetch" href="/assets/js/26.32502535.js"><link rel="prefetch" href="/assets/js/27.c4e43eb4.js"><link rel="prefetch" href="/assets/js/28.e0929e64.js"><link rel="prefetch" href="/assets/js/29.506de4d2.js"><link rel="prefetch" href="/assets/js/30.cde52e66.js"><link rel="prefetch" href="/assets/js/31.80c20f2a.js"><link rel="prefetch" href="/assets/js/32.6a5b0f8f.js"><link rel="prefetch" href="/assets/js/33.ce2401cf.js"><link rel="prefetch" href="/assets/js/34.48d2b08c.js"><link rel="prefetch" href="/assets/js/35.915baeb9.js"><link rel="prefetch" href="/assets/js/36.aa4b4a51.js"><link rel="prefetch" href="/assets/js/37.8dcc8e36.js"><link rel="prefetch" href="/assets/js/38.e09c4d9a.js"><link rel="prefetch" href="/assets/js/39.298fe404.js"><link rel="prefetch" href="/assets/js/40.5dfd072f.js"><link rel="prefetch" href="/assets/js/41.bef62940.js"><link rel="prefetch" href="/assets/js/42.f3709422.js"><link rel="prefetch" href="/assets/js/43.4792a053.js"><link rel="prefetch" href="/assets/js/44.016783bd.js"><link rel="prefetch" href="/assets/js/45.86a2e1e9.js"><link rel="prefetch" href="/assets/js/47.42835cf5.js"><link rel="prefetch" href="/assets/js/48.a3d853de.js"><link rel="prefetch" href="/assets/js/49.e2d918d3.js"><link rel="prefetch" href="/assets/js/50.f8ed1c5c.js"><link rel="prefetch" href="/assets/js/51.2d7018d4.js"><link rel="prefetch" href="/assets/js/52.2b71b381.js"><link rel="prefetch" href="/assets/js/53.c83c1de8.js"><link rel="prefetch" href="/assets/js/54.30130365.js"><link rel="prefetch" href="/assets/js/55.5aa0359b.js"><link rel="prefetch" href="/assets/js/56.eff42d8a.js"><link rel="prefetch" href="/assets/js/57.8a769bbe.js"><link rel="prefetch" href="/assets/js/58.00fde51f.js"><link rel="prefetch" href="/assets/js/59.3770bbf4.js"><link rel="prefetch" href="/assets/js/60.ceaf28f2.js"><link rel="prefetch" href="/assets/js/61.7b8e34a7.js"><link rel="prefetch" href="/assets/js/62.5431f082.js"><link rel="prefetch" href="/assets/js/63.5ae378b9.js"><link rel="prefetch" href="/assets/js/64.396da2f4.js"><link rel="prefetch" href="/assets/js/65.1b8c3887.js"><link rel="prefetch" href="/assets/js/66.2701f99a.js"><link rel="prefetch" href="/assets/js/67.bf7c0f64.js"><link rel="prefetch" href="/assets/js/68.ce924902.js"><link rel="prefetch" href="/assets/js/69.2a48405d.js"><link rel="prefetch" href="/assets/js/70.25741fa0.js"><link rel="prefetch" href="/assets/js/71.026c4f65.js"><link rel="prefetch" href="/assets/js/72.3e225883.js"><link rel="prefetch" href="/assets/js/73.db6491d5.js"><link rel="prefetch" href="/assets/js/74.c5f4353f.js"><link rel="prefetch" href="/assets/js/75.edaa489f.js"><link rel="prefetch" href="/assets/js/76.91e65cdc.js"><link rel="prefetch" href="/assets/js/77.692660ad.js"><link rel="prefetch" href="/assets/js/78.c79f8260.js"><link rel="prefetch" href="/assets/js/79.27aabd12.js"><link rel="prefetch" href="/assets/js/80.3e19e3ce.js"><link rel="prefetch" href="/assets/js/81.77604aae.js"><link rel="prefetch" href="/assets/js/82.c3ed9fe1.js"><link rel="prefetch" href="/assets/js/83.ed8667b9.js"><link rel="prefetch" href="/assets/js/84.c966036c.js"><link rel="prefetch" href="/assets/js/85.de50b1ae.js"><link rel="prefetch" href="/assets/js/86.19e795ae.js"><link rel="prefetch" href="/assets/js/87.4dba67cf.js"><link rel="prefetch" href="/assets/js/88.2a7b9707.js"><link rel="prefetch" href="/assets/js/89.93bda388.js"><link rel="prefetch" href="/assets/js/90.97a6064b.js"><link rel="prefetch" href="/assets/js/91.37ce3856.js"><link rel="prefetch" href="/assets/js/92.cf736dd2.js"><link rel="prefetch" href="/assets/js/93.55005712.js"><link rel="prefetch" href="/assets/js/94.149acba3.js"><link rel="prefetch" href="/assets/js/95.d204cbb7.js"><link rel="prefetch" href="/assets/js/96.51bde9ee.js"><link rel="prefetch" href="/assets/js/97.b6d54691.js"><link rel="prefetch" href="/assets/js/98.244fcc85.js"><link rel="prefetch" href="/assets/js/99.2853e994.js"><link rel="prefetch" href="/assets/js/100.ea317b53.js"><link rel="prefetch" href="/assets/js/101.edad34de.js"><link rel="prefetch" href="/assets/js/103.fa6aeec2.js">
    <link rel="stylesheet" href="/assets/css/104.styles.28e83be5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      技术文档
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><a href="/" class="sidebar-link">技术文档</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>node学习</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>leetcode完成的好的题目</span><!----></p><ul class="sidebar-group-items"><li><a href="/LeetCode/regex.html" class="sidebar-link">正则相关的题目</a></li><li><a href="/LeetCode/string.html" class="sidebar-link">String 相关的题目</a></li><li><a href="/LeetCode/link.html" class="active sidebar-link">链表</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>ES6学习</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Vue源码学习</span><!----></p><ul class="sidebar-group-items"><li><a href="/vue_resource/structure.html" class="sidebar-link">vue目录结构导读</a></li><li><a href="/vue_resource/start.html" class="sidebar-link">Vue之旅开始</a></li><li><a href="/vue_resource/options.html" class="sidebar-link">mergeOption的初始化与合并规则</a></li><li><a href="/vue_resource/init_data.html" class="sidebar-link">init_data</a></li><li><a href="/vue_resource/events.html" class="sidebar-link">内部事件初始始化与事件的实现</a></li><li><a href="/vue_resource/compile_el.html" class="sidebar-link">编译的整个过程与相关方法讲解</a></li><li><a href="/vue_resource/_compile_root.html" class="sidebar-link">编译其他节点</a></li><li><a href="/vue_resource/_compile_rest.html" class="sidebar-link">编译根节点</a></li><li><a href="/vue_resource/directive_base.html" class="sidebar-link">指令的创建与生成及更新</a></li><li><a href="/vue_resource/watch_observer.html" class="sidebar-link">watch</a></li><li><a href="/vue_resource/batcher.html" class="sidebar-link">管理watcher队列</a></li><li><a href="/vue_resource/calculate.html" class="sidebar-link">表达式的运算与执行过滤</a></li><li><a href="/vue_resource/hook.html" class="sidebar-link">钩子函数的初始化与实现</a></li><li><a href="/vue_resource/transition.html" class="sidebar-link">transition实现讲解</a></li><li><a href="/vue_resource/dom.html" class="sidebar-link">DOM操作的几个方法实现</a></li><li><a href="/vue_resource/fragmentFactory.html" class="sidebar-link">工厂</a></li><li><a href="/vue_resource/directive_every.html" class="sidebar-link">内部几个指令的实现讲解</a></li><li><a href="/vue_resource/parse.html" class="sidebar-link">表达式解析的相关实现</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端常见问题</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>前端基础</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>算法</span><!----></p><ul class="sidebar-group-items"><li><a href="/arithmetic/reg_match.html" class="sidebar-link">正则匹配模式</a></li><li><a href="/arithmetic/search_str.html" class="sidebar-link">正则查找子串</a></li><li><a href="/算法/callStack.html" class="sidebar-link">递归调用栈及尾递归的优化</a></li><li><a href="/算法/sort.html" class="sidebar-link">排序算法</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="链表">链表</h1><ol><li>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</li></ol><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL</p><p>解释:</p><ul><li>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</li><li>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</li><li>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</li><li>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</li></ul></div><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || !head-&gt;next || k&lt;=0) return head;
        ListNode *last = head, *c = head, *prev = NULL, *p = head;
            int len=1;
        while(c &amp;&amp; c-&gt;next){
            c = c-&gt;next;
            ++len;
        }
        k %= len;
        while(k&gt;0){
            while(last &amp;&amp; last-&gt;next){
                if(!last-&gt;next-&gt;next){
                    prev = last;
                }
                last = last-&gt;next;
            }
            last-&gt;next = p;
            p = last;
            prev-&gt;next = NULL;
            --k;
        }
        return last;
    }
};
</code></pre><ol start="2"><li>给定一个链表，判断链表中是否有环。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        int i=0;
        ListNode *fast = head, *slow = head;
        if(head != NULL &amp;&amp; head-&gt;next == head){
             return true;   
        }
        while(head != NULL &amp;&amp; fast != NULL){
            slow = slow-&gt;next;
            if(fast-&gt;next != NULL){
                fast = fast-&gt;next-&gt;next;
            }else{
                return false;
            }
            if(slow==head) return true;
            if(fast==head) return true;
            if(slow == fast) return true;
        }
        return false;
    }
};
</code></pre><ol start="3"><li><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p></li></ol><p>说明：不允许修改给定的链表。</p><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        if(head != NULL){
            if(head == head-&gt;next) return head;
            while(fast != NULL &amp;&amp; fast-&gt;next != NULL){
                slow = slow-&gt;next;  
                fast = fast-&gt;next-&gt;next;
                if(slow == fast){
                    ListNode *p = head;
                    while(p != slow){
                        p = p-&gt;next;
                        slow = slow-&gt;next;
                    }
                    return p;
                }
            }
        }
        return NULL;
    }
};
</code></pre><ol start="4"><li>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return sortChild(head, NULL);
    }
private:
    TreeNode* sortChild(ListNode* head, ListNode *tail){
        if(head == tail){
            return NULL;
        }
        if(head-&gt;next == tail){
            TreeNode *root = new TreeNode(head-&gt;val);
            return root;
        }
        ListNode *fast = head, *slow = head;
        while(fast != tail &amp;&amp; fast-&gt;next != tail){
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        TreeNode *root = new TreeNode(slow-&gt;val);
        root-&gt;left = sortChild(head, slow);
        root-&gt;right = sortChild(slow-&gt;next, tail);
        return root;
    }
};
</code></pre><ol start="5"><li>编写一个程序，找到两个单链表相交的起始节点。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL || headB==NULL) return NULL;
        int i = 0, j = 0, k = 0;
        ListNode *a = headA, *b = headB;
        while(a != NULL || b != NULL){
            if(a != NULL){
                a = a-&gt;next;   
                ++i;
            }
            if(b != NULL){
                b = b-&gt;next;   
                ++j;
            }
        }
        int dis = abs(i - j);
        ListNode *find = i&gt;j ? headA : headB;
        ListNode *short_one = i&gt;j ? headB : headA;
        while(find != short_one &amp;&amp; find != NULL &amp;&amp; short_one != NULL){
            find = find-&gt;next;
            if(dis &gt; k){
                ++k;
            }else{
                short_one = short_one-&gt;next;
            }
        }
        if(find == short_one){
            return find;
        }else{
            return NULL;
        }
        
    }
};

</code></pre><ol start="6"><li>反转一个单链表。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = NULL, *cur = head, *next=NULL;
        while(cur != NULL){
            next = cur-&gt;next;
            cur-&gt;next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
};
</code></pre><ol start="7"><li>删除链表中等于给定值 val 的所有节点。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *cur;
        while(head != NULL &amp;&amp; head-&gt;val == val){
            head = head-&gt;next;
        }
        if(head == NULL) return NULL;
        cur = head;
        while(cur-&gt;next != NULL){
            if(val == cur-&gt;next-&gt;val){
                cur-&gt;next = cur-&gt;next-&gt;next;
            }else{
                cur = cur-&gt;next;
            }
        }
        return head;
        
    }
};
</code></pre><ol start="8"><li>请判断一个链表是否为回文链表。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    ListNode* findMid(ListNode* head){
        ListNode *p = head, *mid = head;
        while(p &amp;&amp; p-&gt;next){
            mid = mid-&gt;next;
            p = p-&gt;next-&gt;next;
        }
        return mid;
    }
    ListNode* reserveList(ListNode* head){
        ListNode *prev = NULL, *temp = NULL;
        while(head){
            // 暂存next结点
            temp = head-&gt;next;
            // 更新当前结点的next指向
            head-&gt;next = prev;
            // 更新上一结点
            prev = head;
            // 更新当前结点
            head = temp;
        }
        return prev;
    }
public:
    int isPalindrome(ListNode* head) {
        if(!head || !head-&gt;next) return true;
        else if(head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val &amp;&amp; !head-&gt;next-&gt;next) return true;
        else if(head &amp;&amp; head-&gt;next &amp;&amp; !head-&gt;next-&gt;next) return false;
        ListNode *mid = findMid(head);
        cout&lt;&lt;mid-&gt;val&lt;&lt;endl;
        mid = reserveList(mid);
        ListNode *before = head, *after = mid;
        while(before &amp;&amp; after &amp;&amp; before-&gt;val == after-&gt;val){
            before = before-&gt;next;
            after = after-&gt;next;
        }
        return after == NULL;
        
    }
};
</code></pre><ol start="9"><li>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</li></ol><p>注：请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head) return NULL;
        else if(!head-&gt;next) return head;
        ListNode *odd = head, *even = head-&gt;next, *temp = head-&gt;next;
        while(odd != NULL &amp;&amp; even !=NULL  &amp;&amp; odd-&gt;next !=NULL){
            odd-&gt;next = even-&gt;next;
            if(odd-&gt;next){
                odd = odd-&gt;next;
            }
            if(even &amp;&amp; odd){
                even-&gt;next = odd-&gt;next;
                even = even-&gt;next;
            }
        }
        odd-&gt;next = temp;
        return head;
    }
};
</code></pre><ol start="10"><li>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</li></ol><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index - 大于链表长度，则不会插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><pre class="language-text"><code>typedef struct node{
    struct node *prev;
    struct node *next;
    int val;
}LinkNode;

class MyLinkedList {
    protected:
    LinkNode *head;
    int size;
public:
    /** Initialize your data structure here. */
    MyLinkedList() {
        head = NULL;
        size = 0;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    int get(int index) {
        int i = 1;
        LinkNode *p = head;
        if(index&lt;0 || head == NULL || index&gt;size-1) return -1;
        if(index == 0){
            return head-&gt;val;
        }else{
            while(i&lt;=index &amp;&amp; p-&gt;next != NULL){
                p = p-&gt;next;
                ++i;
            }
            return p-&gt;val;
        }
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    void addAtHead(int val) {
        LinkNode *p;
        p = (LinkNode *)malloc(sizeof(LinkNode));
        p-&gt;val = val;
        p-&gt;next = head;
        head = p;
        ++size;
    }
    
    /** Append a node of value val to the last element of the linked list. */
    void addAtTail(int val) {
        LinkNode *p = head;
        LinkNode *s;
        s = (LinkNode *)malloc(sizeof(LinkNode));
        while(p-&gt;next != NULL){
            p = p-&gt;next;
        }
        s-&gt;val = val;
        s-&gt;next = NULL;
        p-&gt;next = s;
        ++size;
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    void addAtIndex(int index, int val) {
        if(index&gt;size) return;
        if(index == 0 || size == 0){
            addAtHead(val);
        }else if(index == size){
            addAtTail(val);
        }else{
            int i = 1;
            LinkNode *p = head;
            LinkNode *s;
            s = (LinkNode *)malloc(sizeof(LinkNode));
            s-&gt;val = val;
            while(index &lt;size &amp;&amp; i&lt;index &amp;&amp; p-&gt;next != NULL){
                p = p-&gt;next;
                ++i;
            }
            s-&gt;next = p-&gt;next;
            p-&gt;next = s;
            ++size;
        }
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    void deleteAtIndex(int index) {
        if(index == 0){
            head = head-&gt;next;
            --size;
        }else if(index&lt;size){
            int i = 1;
            LinkNode *p = head;
            while(p-&gt;next != NULL &amp;&amp; i&lt;index){
                p = p-&gt;next;
                ++i;
            }
            p-&gt;next = p-&gt;next-&gt;next;
            --size;
        }
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
</code></pre><ol start="11"><li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *cur = head, *prev = NULL, *temp = head;
        int len = 0, index;
        if(n==1 &amp;&amp; temp-&gt;next == NULL){
            return NULL;
        }
        while(temp){
            // 删除最后一项
            len++;
            temp = temp-&gt;next;
            
        }
        index = len - n;
        cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;len&lt;&lt;endl;
        //  删除第一项
        if(len==n){
            return head-&gt;next;
        }
        while(cur &amp;&amp; index&gt;=0){
            if(index == 0){
                if(!prev){
                    prev = cur;
                    cur = cur-&gt;next;
                }
                prev-&gt;next = cur-&gt;next;
                prev = prev-&gt;next;
                if(prev){
                    cur = prev-&gt;next;
                }else{
                    cur = NULL;
                }
                break;
            }else{
                prev = cur;
                cur = cur-&gt;next;
                index--;
            }
        }
        return head;
    }
};
</code></pre><ol start="12"><li>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</li></ol><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1 &amp;&amp; !l2) return NULL;
        else if(l1 &amp;&amp; !l2) return l1;
        else if(!l1 &amp;&amp; l2) return l2;
        ListNode *p = l1, *l3 = NULL, *q = l2, *newHead = NULL;
        if(p &amp;&amp; q){
            if(p-&gt;val&lt;=q-&gt;val){
                l3 = p;
                newHead = p;
                p = p-&gt;next;
            }else{
                l3 = q;
                newHead = q;
                q = q-&gt;next;
            }
        }
        while(p &amp;&amp; q){
            if(p-&gt;val&lt;=q-&gt;val){
                l3-&gt;next = p;
                p = p-&gt;next;
            }else{
                l3-&gt;next = q;
                q = q-&gt;next;
            }
            l3 = l3-&gt;next;
        }
        if(p != NULL) l3-&gt;next = p;
        if(q != NULL) l3-&gt;next = q;
        return newHead;
    }
};
</code></pre><ol start="13"><li>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</li></ol><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>说明:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul></div><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head-&gt;next) return head;
        ListNode *odd = head, *newHead = head-&gt;next, *even = newHead, *next = NULL, *temp = NULL;
        while(even){
            temp = even-&gt;next;
            if(temp &amp;&amp; temp-&gt;next){
                next = temp-&gt;next;
            }else if(temp &amp;&amp; !temp-&gt;next){
                next = temp;
            }else{
                next = NULL;
            }
            if(odd){
                even-&gt;next = odd;
                odd-&gt;next = next;
                odd = temp;
            }
            if(odd &amp;&amp; odd-&gt;next){
                even = odd-&gt;next;   
            }else{
                even = NULL;
            }
        }
        return newHead;
    }
};
</code></pre></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/LeetCode/string.html" class="prev">
          String 相关的题目
        </a></span><span class="next"><a href="/es6/set&amp;map.html">
          Set &amp; Map
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/102.9e7d2641.js" defer></script><script src="/assets/js/app.7cebdd4c.js" defer></script>
  </body>
</html>
