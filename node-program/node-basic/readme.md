「性能分析」，「性能测试」，「内存管理」，「内存查看」，「使用C++插件」，「子进程」，「多线程」，「Cluster模块」，「进程守护管理」

1. 搭建基础服务 HTTP 服务器
2. 连接 DB，定义接口，创建、增删、改查询 DB
3. 缓存层
4. 接口数据
5. 性能测试、压测
   + ab 官方文档：ab -c200 -n1600 http://127.0.0.1:3000/index
   + webbench
   + autocannon

参数	解释
-c concurrency	设定并发数，默认并发数是 1
-n requests	设定压测的请求总数
-t timelimit	设定压测的时长，单位是秒
-p POST-file	设定 POST 文件路径，注意设定匹配的 -T 参数
-T content-type	设定 POST/PUT 的数据格式，默认为 text/plain
-V	查看版本信息
-w	以Html表格形式输出

6. Nodejs性能分析工具：profile，在启动的时候加上**--prof**即可 和 chrome devtools
   + node --prof index.js
   + 目录下会立马生成一个文件isolate-0x104a0a000-25750-v8.log
   + 「NodeJs」自带的命令 node --prof-process isolate-0x104a0a000-25750-v8.log > profile.txt
   + node --inspect-brk index.js；--inspect, -brk代表启动调试的同时暂停程序运行
   + 这时监听了一个websocket，我们就可以通过这个ws进行调试了，地址栏输入chrome://inspect，点击「inspect」就可以进行调试

7. 代码性能优化
   + 「NodeJs」的底层是基于「C++」 ，最终识别的数据结构还是「buffer」，所以 Buffer 更快
   + 文件操作，以流的方式会更快
   + 减少不必要的计算：「NodeJs」中计算会占用相当大的一部分cpu，包括一些文件的编解码等等，尽量要避免这些操作。
   + 空间换时间：比如上面这种读取，或者一些计算，我们可以`缓存`起来，下次读取的时候直接调用。

8. 内存管理
   + 垃圾回收机制：
     + 「GC垃圾回收机制」，垃圾回收机制分为，`新生代`和`老生代`两部分，所有新创建的变量都会先进入新生代部分，当新生代内存区域快要`分配满`的时候，就会进行一次垃圾回收，把无用的变量清除出去给新的变量使用，同时，如果一个`变量在多次垃圾回收之后依然存在`，那么则认为其是一个`常用且不会轻易移除`的变量，就会将其放入`老生代`区域，这样一个循环，同时，`老生代区域容量更大`，垃圾回收`相对更慢`一些。
     + 新生代：容量小、垃圾回收更快
     + 老生代：容量大，垃圾回收更慢
     + 所以减少内存的使用也是提高服务性能的手段之一，如果有内存泄漏，会导致服务器性能大大降低。
   + 内存泄漏问题处理与修复：「Memory面板」可以检测，点击面板之后点击右上角远点会产生一个快照，显示当前使用了多少内存空间
   + 控制内存使用:
     + 「NodeJs」的「Buffer」的内存分配策略：一种是「小于8kb」的文件，一种是「大于8kb」的文件，小于8kb的文件NodeJs认为频繁的去创建没有必要，所以每次都会先创建一个8kb的空间，然后得到空间之后的去计算「buffer」的占用空间，如果小于8kb就在8kb中给它切一部分使用，依次内推，如果遇到一个小于8kb的「buffer」使余下的空间不够使用的时候就会去开辟新的一份8kb空间，在这期间，如何有任何变量被销毁，则这个空间就会被释放，让后面的使用，这就是「NodeJs」中「Buffer」的空间分配机制，这种算法类似于一种「池」的概览。如果在我们的编码中也会遇到内存紧张的问题，那么我们也可以采取这种策略。
9. Node多进程使用优化
   + 进程：拥有系统挂载运行程序的单元 拥有一些独立的资源，比如内存空间
   + 线程：进行运算调度的单元 进程内的线程共享进程内的资源 一个进程是可以拥有多个线程的
   + 「NodeJs」中一般启动一个服务会有一个主线程和四个子线程，在「NodeJs」中，主线程运行「v8」与「javascript」，主线程负责主要流程和下发各种工作，通过「时间循环机制」 、「LibUv」再由四个子线程去进行工作。
   + 因为「js」是一门单线程的语言，它正常情况下只能使用到一个「cpu」，不过其「子线程」在 底层也使用到了`其他「cpu」`，但是依然没有完全解放多核的能力，当计算任务过于繁重的时候，我们就可以也在其他的「cpu」上跑一个「javascript」的运行环境，那么我么先来看看如何用子进程来调用吧
10. 进程的使用 child_process：master，child

```js
/* master.js */
/* 自带的子进程模块 */
const cp = require('child_process')
/* fork一个地址就是启动了一个子进程，每「fork」一次便可以开启一个子进程*/
const child_process = cp.fork(__dirname + '/child.js')
/* 通过send方法给子进程发送消息 */
child_process.send('主进程发这个消息给子进程')
/* 通过 on message响应接收到子进程的消息 */
child_process.on('message', (str) => {
  console.log('主进程：接收到来自自进程的消息', str);
})


/* chlid.js */
/* 通过on message 响应父进程传递的消息 */
process.on('message', (str) => {
  console.log('子进程， 收到消息', str)
  /* process是全局变量 通过send发送给父进程 */
  process.send('子进程发给主进程的消息')
})
```

11. Cluster模块
    + 「NodeJs」的部署，目前我们在用的是「Pm2」，其实现原理就是基于这种模块，如果我们可以在不同的核分别去跑一个「http服务」那么是不是类似于我们后端的集群，部署多套服务呢，当客户端发送一个「Http请求」的时候进入到我们的「master node」，当我们收到请求的时候，我们把其请求发送给子进程，让子进程自己处理完之后返回给我，由主进程将其发送回去，那么这样我们是不是就可以利用服务器的多核呢？答案是肯定的，同时这些都不需要我们做过多的东西，这个模块就帮我们实现了，然后我们来实现一个这样的服务，我们创建两个文件app.js,cluster.js，第一个文件呢就是我们日常的启动文件，我们来简单的，使用我们的最开始的那个服务即可：
    + 就这样简单的代码就可以让我们的请求分发到不同的子进程里面去，这一点类似于负载均衡，非常简单，同时我们在启用多线程和没启动的前后分别压测，可以发现启用后的「qps」是前者的「2.5倍」拥有很大的一个提升了，也可以知道进程直接的通信是有损耗的，不然应该就是「三倍」了，那么我们要开启多少个子进程比较合适呢。我们可以使用内置模块「OS」，来获取到当前计算机的「cpu核数」的，我们加一点简单改造
12. NodeJs进程守护与管理

