
+ 二进制分帧
+ 请求多路复用
+ 头部压缩:  HPack使用哈夫曼编码和索引表实现，需要客户端和服务器都维护一个`表头字段的索引表`
+ 服务器推送：有服务器根据解析 index.html 同事推送资源信息
+ 赋予请求优先级
+ Curl 不支持 HTTP2
+ 头阻塞：出现在 TCP 层？ HTTP/2 多路复用的并行特性对于 TCP 的丢包恢复机制是不可见的，一个丢失或顺序不对的数据包会导致所有活动的事务停顿，无论其是否受到丢包的直接影响。因为 HTTP2 开了太多并行的 TCP 连接
+ 距离远？丢包可能性更大？

为什么 HTTP1.1 没有办法实现多路复用？

+ HTTP1.1为什么没有多路复用：HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

+ HTTP的缺点
  1. 通信使用明文，可能会被窃听
  2. 不验证通信方的身份，可能遭遇伪装----查证书
  3. 无法证明报文的完整性，可能被篡改----数字签名校验
  4. 可通过SSL或TLS的组合使用，加密HTTP的通信内容，即HTTPS
  5. HTTP是无状态协议：通过 Cookie 标识

+ HTTP3 标准跟踪 RFC---QUIC通用的传输协议：包含流的复用和对每个流的流量控制，这两者与 HTTP/2 中实现的类似。通过在整个连接中提供流级别的可靠性和拥塞控制，比起 TCP 映射，QUIC 更能提高 HTTP 的性能
+ 支持 0-RTT QUIC 连接，减少了建立安全 TLS 连接的数据往返次数。

+ HTTPS 主要解决的三个安全问题---握手过程主要是和服务器做通讯，生成`私有秘钥`，最后通过该秘钥`对称加密传输数据`。还有`验证证书`的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。
  + 内容隐私
  + 防篡改
  + 确认对方身份
  + TLS----SSL 协商

+ TCP 传输层
  1. 对数据进行`分割`，打上`标记序号及端口号`，发送给网络层；
  2. (IP)网络层`增加MAC地址`后转发给链路层
  3. 三次握手策略：数据发送出去后，会向对应确认是否已送达，过程中使用的TCP的flag---`SYN和ACK`
      + 发送端发送一个带`SYN标志`(建立联机)的数据包给对方----建立
      + 接收端收到后回传一个`SYN/ACK标志`(确认：原SYN+1)的数据包以示传达确认信息-----传达确认
      + 最后发送端再回传一个带`ACK+1`标志的数据包；以示结束。-----确认收到
  4. 四次挥手??
      + 客户端发送一个`FIN标记`(结束)的数据包到服务端
      + 服务端收到后再返回一个`ACK标志`的数据包回来
      + `服务器端关闭`与客户端的连接，再发送一个`FIN给到客户端`
      + 客户端再发回ACK的数据包确认
+ 其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

+ TLS 握手过程
+ wireshark 抓包 https/http2
+ http3，基于 UDP，解决了对头阻塞与 TCP 和 TLS握手时的延迟问题

## 应用

+ 雪碧图
+ 图标字体
+ 资源合并
