+ 正则执行的基本原理与过程及其优化策略

+ 正则表达是匹配模式，要么匹配字符，要么匹配位置

## 正则基础点

+ 横向匹配----长度不固定；纵向模糊匹配----不确定的字符[xxxx]
+ 字符组与排查字符组及量词
+ 贪婪与惰性模式----?
+ 正向预查(?=p)与(?!p)、反向预查(?<=)与(?<!):更多的是作为`限制条件使用`
  + 不消耗字符。也就是说，在一个匹配发生后，匹配字符之后立即开始下一次匹配的搜索，而`不是从包含预查的字符之后`开始
+ 匹配位置----^、$、\b、\B，正向预查(?=p)与(?!p)、反向预查(?<=)；
  + \b 单词边界，即\W与\w 直接的位置，包括\w 和^，\w 和$直接的位置，剩下的都是\B
  + p 为一个子模式，(?=p)匹配的是 p 前面的位置；
  + p 为一个子模式，(?!p)匹配的是前面不是 p 的位置
+ 括号----分组捕获与非捕获----$1, $2...----反向引用\1...\10；
  + 表示\和 0时，使用(?:\1)0或\1(?:0)
  + 引用不存在的分组：如\2，即是对 2的转义
  + 分组后面有量词时，则捕获的是最后一次的匹配，如：/(\d)+ \1/.test("12345 5")
+ 分支----|
+ 回溯
  + 贪婪模式下：模糊度过高，直接匹配到比较考结束位置了，下一个匹配项无法匹配，则需要向前回溯，如下面横向对比的例子-----使字符组匹配尽量精确，不要范围过大
  + 惰性模式下：匹配过少，后面的匹配不了，前一个匹配要再想后匹配，直到后一个匹配成功或者整体匹配失败
  + 分支结构：多条匹配道路，第一个使整体匹配成功的道路，匹配不成功也要进行多次回溯
+ 修饰符---g, i, m多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾

\d\D表示的范围?\s\S？\s\S?
两个锚点在一起，其的作用？/(?=.*[0-9])^/

+ 找到 div 内的 p 标签：/<div[^>]+>[^<]*(?=<p)[^>]+>[^<]*(?=<\/p>)/
+ 性能优化：优化尝试（比较）次数与回溯次数
+ 正向环视
+ 反向环视
+ 例子：
  + /^([01][0-9]|[2][0-3]):[0-5][0-9]$/  时：分
  + /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/  时：分：秒
  + /^[0-9]{4}-(0[1-9]|[1][0-2])-(0[1-9]|[12][0-9]|3[01])$/ 日期
  + 不包含特殊字符：/[^\\:*<>|"?\r\n/]/
  + ([^\\:*<>|"?\r\n/]+\\)*
  + ([^\\:*<>|"?\r\n/]+)?
  + "12345678".replace(/(?=(\d{3})+$)/g, ","); 后面跟随三个数字，没有排除开始位
  + "123456789".replace(/(?!^)(?=(\d{3})+$)/g, ",");
  + "12345678 123456789".replace(/(?!\b)(?=(\d{3})+\b)/g, ","); 用空格时的数字
  + /(?<=\d)(?=(\d{3})+$)/g;
  + Num.toFixed(2).replace(/\B(?=(\d{3})+\b)/, ",").replace(/^/,"$$ ");
  + IPv4 /^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/
  + /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/ 必须包含一个字符（数字） + 密码长度 6-12 位数字或字母
  + /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/ 必须包含小写字母与数字 6-12 位数字或字母
  + /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/  密码长度 6-12 位数字或字母，即 不能全是数字 或 不能全是大写或小写字母
+ 横向例子对比：
/id=".*"/  贪婪模式，会持续匹配到最后一个“结束
/id=".*?"/  惰性匹配，存在回溯次数过多的问题
/id="[^"]*"/  用否定字符组匹配

+ 优化的例子：缩短了引擎从开始工作到反馈匹配结果（成功/失败）的时间
/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/
然后提取公共部分：/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/
再优化：/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/

/^[+-]?(\d+\.\d+|\d+|\.\d+)$/
/^([+-])?(\d+\.\d+|\d+|\.\d+)$/
/^[+-]?(\d+)?(\.)?\d+$/

+ 不消费字符？匹配一个位置，也就是不获取字符串，不消费字符：
  + /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{4,8}$/ 只是限定了前面或者后面匹配的规则，而不占用匹配的字符。
  + (?<=\s)\d+(?=\s) 匹配两边是空白符的数字，不包括空白符
+ 捕获---相关匹配存储到一个`临时缓冲区`中，所捕获的每个子匹配都按照在正则表达式模式中从左到右`出现的顺序存储`。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。
+ 非捕获---这种分组正则表达式引擎不会捕获它所匹配的内容即不会为非捕获型分组`分配组号`，也就是不放在我们的`内存`当中，这样也能提高我们的性能
+ 贪婪与懒惰(即加上?号)
+ 构建正则时考虑的点
  + 准确性，匹配预期的字符串
  + 准确性，不匹配非预期的字符串
  + 可读性和可维护性
  + 提取正则的公共部分，使用反向引用，不断的提取优化
  + 效率
  + 是否需要复杂的正则，是否可以拆分成几个，分段匹配
+ 正则表达式运行过程与优化
  + 编译
  + 设定起始位置
  + 尝试匹配
  + 若匹配失败则返回前一步重新匹配
  + 返回匹配成功失败的结果
  + 常用优化手段：
    + 精确字符组匹配范围
    + 当不需要分组或反向引用时，使用非捕获型分组
    + 独立出确定字符，加快判断是否匹配失败，进而加快移位的速度
    + 提取分支公共部分，建设分支个数
  + 使用 search, test, match, exec, split, replace 进行正则验证，其中 search与 match 会把字符串参数转换成正则，所以要加转义

+ 各个库中优秀的正则

+ 常用的字符组：
  + [\u4e00-\u9fa5]

## 写个函数，判断一个字符串是否为手机靓号，手机靓号条件：有3个连续相同的数字如 '111' 或者 有4个依次递增1的数字 '1234'【编程】
