### 正则基础

正则是、短小精悍、能力强的高精简武器，所以以下是使用该高精尖武器的步骤与练习方法

::: tip
正则表达是要么匹配模式，要么匹配字符，要么匹配位置



下面请先欣赏 Vue 中对该武器的使用：

```js
// 小甜点，看出来他们用来完成哪些功能了吗？答案会在后面揭晓，对后面看 Vue 模板编译与解析部分非常有帮助
onRE = /^@|^v-on:/
dirRE = process.env.VBIND_PROP_SHORTHAND
  ? /^v-|^@|^:|^\.|^#/
  : /^v-|^@|^:|^#/
stripParensRE = /^\(|\)$/g
dynamicArgRE = /^\[.*\]$/
argRE = /:(.*)$/
bindRE = /^:|^\.|^v-bind:/
propBindRE = /^\./
modifierRE = /\.[^.\]]+(?=[^\]]*$)/g
slotRE = /^v-slot(:|$)|^#/
lineBreakRE = /[\r\n]/
whitespaceRE = /[ \f\t\r\n]+/g
invalidAttributeRE = /[\s"'<>\/=]/
// 这个是否可以优化？前面用到懒惰模式，后面用贪婪模式？这里的的优点？
forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/

// text 部分的解析
defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g
regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g

// 构建出需要的正则
const buildRegex = cached(delimiters => {
  const open = delimiters[0].replace(regexEscapeRE, '\\$&')
  const close = delimiters[1].replace(regexEscapeRE, '\\$&')
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})

// filter 部分的
validDivisionCharRE = /[\w).+\-_$\]]/


// 高级部分
// 匹配函数定义
fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/
// 匹配函数调用部分
fnInvokeRE = /\([^)]*?\);*$/
// 表达式属性访问路径匹配
simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/

```

#### 正则相关关键词讲解

1. 捕获：将需要捕获的内容放入一对小括号内()；捕获将相关匹配存储到一个`临时缓冲区`中，所捕获的每个子匹配都按照在正则表达式模式中从左到右`出现的顺序存储`。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。
2. 非捕获：(?:)需要分组，但不捕获；这种分组正则表达式引擎不会捕获它所匹配的内容即不会为非捕获型分组`分配组号`，也就是不放在我们的`内存`当中，这样也能提高我们的性能
3. 贪婪「*, +，{2,}」与 懒惰「\*? 或 +?」
4. 常用表达式量：\w,\d,\s, \S, \r, \n, \t
5. 常用捕获位置：
6. 正向肯定预测，正向否定预测：
7. 构建正则时考虑的点
   + 准确性，匹配预期的字符串
   + 准确性，不匹配非预期的字符串
   + 可读性和可维护性
   + 提取正则的公共部分，使用反向引用，不断的提取优化
   + 效率
   + 是否需要复杂的正则，是否可以拆分成几个，分段匹配
8. 正则表达式运行过程与优化
   + 编译
   + 设定起始位置
   + 尝试匹配
   + 若匹配失败则返回前一步重新匹配
   + 返回匹配成功失败的结果
   + 常用优化手段：
     + 精确字符组匹配范围
     + 当不需要分组或反向引用时，使用非捕获型分组
     + 独立出确定字符，加快判断是否匹配失败，进而加快移位的速度
     + 提取分支公共部分，建设分支个数
9. 使用 search, test, match, exec, split, replace 进行正则验证，其中 search与 match 会把字符串参数转换成正则，所以要加转义

+ 常用的字符组：
  + [\u4e00-\u9fa5]

### 正则例子

```javascript
  /<div[^>]+>[^<]*(?=<p)[^>]+>[^<]*(?=<\/p>)/  //找到 div 内的 p 标签
  /^([01][0-9]|[2][0-3]):[0-5][0-9]$/  // 时：分
  /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/  //时：分：秒
  /^[0-9]{4}-(0[1-9]|[1][0-2])-(0[1-9]|[12][0-9]|3[01])$/ 日期
  /[^\\:*<>|"?\r\n/]/ //不包含特殊字符
  /([^\\:*<>|"?\r\n/]+\\)*/
  /([^\\:*<>|"?\r\n/]+)?/
  "12345678".replace(/(?=(\d{3})+$)/g, ","); //后面跟随三个数字，没有排除开始位
  "123456789".replace(/(?!^)(?=(\d{3})+$)/g, ",");
  "12345678 123456789".replace(/(?!\b)(?=(\d{3})+\b)/g, ","); //用空格时的数字
  /(?<=\d)(?=(\d{3})+$)/g;
  Num.toFixed(2).replace(/\B(?=(\d{3})+\b)/, ",").replace(/^/,"$$ ");
  IPv4 /^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/
  /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/ //必须包含一个字符（数字） + 密码长度 6-12 位数字或字母
  /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/ //必须包含小写字母与数字 6-12 位数字或字母
  /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/  //密码长度 6-12 位数字或字母，即 不能全是数字 或 不能全是大写或小写字母
```

横向例子对比：

```javascript
/id=".*"/  //贪婪模式，会持续匹配到最后一个“结束

/id=".*?"/  //惰性匹配，存在回溯次数过多的问题

/id="[^"]*"/  //用否定字符组匹配
```

### 优化的例子：缩短了引擎从开始工作到反馈匹配结果（成功/失败）的时间

```javascript
/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/

/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/ //提取公共部分

/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/ //优化：

// 实数
/^[+-]?(\d+\.\d+|\d+|\.\d+)$/
/^([+-])?(\d+\.\d+|\d+|\.\d+)$/
/^[+-]?(\d+)?(\.)?\d+$/
```

+ ?!不消费字符匹配一个位置，也就是不获取字符串，不消费字符：
  + 如：/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{4,8}$/ 只是限定了前面或者后面匹配的规则，而不占用匹配的字符。
  + (?<=\s)\d+(?=\s) 匹配两边是空白符的数字，不包括空白符



TODO
> 写个函数，判断一个字符串是否为手机靓号，手机靓号条件：有3个连续相同的数字如 '111' 或者 有4个依次递增1的数字 '1234'【编程】



> 疑问：[\d\D]表示的范围 与[\s\S] 整体表示的范围是否一致？




> /(?=.*[0-9])^/两个锚点在一起，其的作用？
