# 正则执行的基本原理与过程及其优化策略

**正则表达是是匹配模式，要么匹配字符，要么匹配位置**

## 正则基础点

1. 横向匹配----长度不固定；纵向模糊匹配----不确定的字符[xxxx]
2. 字符组与排查字符组及量词
3. 贪婪与惰性模式----?
4. 匹配位置----^、$、\b、\B，正向匹配(?=p)与(?!p)、反向匹配(?<=)；
   1. \b 单词边界，即\W与\w 直接的位置，包括\w 和^，\w 和$直接的位置，剩下的都是\B
   2. p 为一个子模式，(?=p)匹配的是 p 前面的位置；如：
   3. p 为一个子模式，(?!p)匹配的是前面不是 p 的位置
5. 括号----分组捕获与非捕获----$1, $2...----反向引用\1...\10；
   1. 表示\和 0时，使用(?:\1)0或\1(?:0)
   2. 引用不存在的分组：如\2，即是对 2的转义
   3. 分组后面有量词时，则捕获的是最后一次的匹配，如：/(\d)+ \1/.test("12345 5")
6. 分支----|
7. 回溯
   1. 贪婪模式下：模糊度过高，直接匹配到比较考结束位置了，下一个匹配项无法匹配，则需要向前回溯，如下面横向对比的例子-----使字符组匹配尽量精确，不要范围过大
   2. 惰性模式下：匹配过少，后面的匹配不了，前一个匹配要再想后匹配，直到后一个匹配成功或者整体匹配失败
   3. 分支结构：多条匹配道路，第一个使整体匹配成功的道路，匹配不成功也要进行多次回溯
8. 修饰符---g, i, m多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾

\d\D表示的范围?
\s\S

例子：

1. /^([01][0-9]|[2][0-3]):[0-5][0-9]$/
2. /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/
3. /^[0-9]{4}-(0[1-9]|[1][0-2])-(0[1-9]|[12][0-9]|3[01])$/
4. 不包含特殊字符：/[^\\:*<>|"?\r\n/]/
5. ([^\\:*<>|"?\r\n/]+\\)*
6. ([^\\:*<>|"?\r\n/]+)?
7. "12345678".replace(/(?=(\d{3})+$)/g, ",");
8. "123456789".replace(/(?!^)(?=(\d{3})+$)/g, ",");
9. "12345678 123456789".replace(/(?!\b)(?=(\d{3})+\b)/g, ",");
10. Num.toFixed(2).replace(/\B(?=(\d{3})+\b)/, ",").replace(/^/,"$$ ");
11. IPv4 /^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/


// 必须包含一个字符（数字） + 密码长度 6-12 位数字或字母
/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/

// 必须包含两个个字符（数字和小写字符）  + 密码长度 6-12 位数字或字母
/(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/

// 密码长度 6-12 位数字或字母
// 即 不能全是数字 或 不能全是大写或小写字母

/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/

横向例子对比：
/id=".*"/  贪婪模式，会持续匹配到最后一个“结束
/id=".*?"/  惰性匹配，存在回溯次数过多的问题
/id="[^"]*"/  用否定字符组匹配


## 构建正则时考虑的点

- 准确性，匹配预期的字符串
- 准确性，不匹配非预期的字符串
- 可读性和可维护性
- 提取正则的公共部分，使用反向引用，不断的提取优化
- 效率
- 是否需要复杂的正则，是否可以拆分成几个，分段匹配

/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/
然后提取公共部分：/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/
再优化：/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/

/^[+-]?(\d+\.\d+|\d+|\.\d+)$/
/^([+-])?(\d+\.\d+|\d+|\.\d+)$/
/^[+-]?(\d+)?(\.)?\d+$/

## 正则表达式运行过程与优化

1. 编译
2. 设定起始位置
3. 尝试匹配
4. 若匹配失败则返回前一步重新匹配
5. 返回匹配成功失败的结果
6. 常用优化手段：
   1. 精确字符组匹配范围
   2. 当不需要分组或反向引用时，使用非捕获型分组
   3. 独立出确定字符，加快判断是否匹配失败，进而加快移位的速度
   4. 提取分支公共部分，建设分支个数
7. 使用 search, test, match, exec, split, replace 进行正则验证，其中 search与 match 会把字符串参数转换成正则，所以要加转义

## 各个库中优秀的正则

1. 常用的字符组：
   1. [\u4e00-\u9fa5]
